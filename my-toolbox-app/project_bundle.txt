--- START OF FILE project_bundle.txt ---

--- PROJECT STRUCTURE ---

my-toolbox-app/
├── public/
├── src/
│   ├── assets/
│   ├── components/
│   │   ├── bits/
│   │   │   ├── Beams.tsx
│   │   │   ├── CircularText.tsx
│   │   │   ├── ClickSpark.tsx
│   │   │   ├── Dock.tsx
│   │   │   ├── FuzzyText.tsx
│   │   │   ├── PixelBlast.tsx
│   │   │   ├── ShinyText.tsx
│   │   │   ├── Silk.tsx
│   │   │   ├── StaggeredMenu.tsx
│   │   │   └── TargetCursor.tsx
│   │   ├── ui/
│   │   │   ├── blurry-button.tsx
│   │   │   ├── button.tsx
│   │   │   ├── card.tsx
│   │   │   ├── color-picker.tsx
│   │   │   ├── dialog.tsx
│   │   │   ├── download-button.tsx
│   │   │   ├── input.tsx
│   │   │   ├── label.tsx
│   │   │   ├── popover.tsx
│   │   │   ├── select.tsx
│   │   │   ├── separator.tsx
│   │   │   ├── sheet.tsx
│   │   │   ├── slider.tsx
│   │   │   └── textarea.tsx
│   │   ├── ErrorBoundary.tsx
│   │   ├── Layout.tsx
│   │   └── PixelBlast.tsx
│   ├── hooks/
│   │   └── useFontLoader.ts
│   ├── lib/
│   │   └── utils.ts
│   ├── pages/
│   │   ├── tools/
│   │   │   ├── PlaceholderTool.tsx
│   │   │   └── QRCodeGenerator.tsx
│   │   ├── HomePage.tsx
│   │   └── NotFoundPage.tsx
│   ├── index.css
│   ├── main.tsx
│   └── tools.ts
├── .gitignore
├── README.md
├── components.json
├── eslint.config.js
├── index.html
├── package.json
├── postcss.config.mjs
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts

--- END OF PROJECT STRUCTURE ---

--- START OF FILE .gitignore ---
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

--- END OF FILE .gitignore ---

--- START OF FILE README.md ---
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

--- END OF FILE README.md ---

--- START OF FILE components.json ---
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}

--- END OF FILE components.json ---

--- START OF FILE eslint.config.js ---
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])

--- END OF FILE eslint.config.js ---

--- START OF FILE index.html ---
<!doctype html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Toolbox</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chewy&family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
--- END OF FILE index.html ---

--- START OF FILE package.json ---
{
  "name": "my-toolbox-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slider": "^1.3.6",
    "@radix-ui/react-slot": "^1.2.3",
    "@react-three/drei": "^10.7.6",
    "@react-three/fiber": "^9.3.0",
    "@tailwindcss/postcss": "^4.1.14",
    "autoprefixer": "^10.4.21",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "color": "^5.0.2",
    "gsap": "^3.13.0",
    "lucide-react": "^0.544.0",
    "motion": "^12.23.22",
    "postcss": "^8.5.6",
    "postprocessing": "^6.37.8",
    "qrcode.react": "^4.2.0",
    "radix-ui": "^1.4.3",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^7.9.3",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^4.1.14",
    "three": "^0.180.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@types/color": "^4.2.0",
    "@types/node": "^24.6.2",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "tw-animate-css": "^1.4.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7"
  }
}

--- END OF FILE package.json ---

--- START OF FILE postcss.config.mjs ---
export default {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

--- END OF FILE postcss.config.mjs ---

--- START OF FILE tsconfig.app.json ---
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

--- END OF FILE tsconfig.app.json ---

--- START OF FILE tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path Alias Configuration */
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
--- END OF FILE tsconfig.json ---

--- START OF FILE tsconfig.node.json ---
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "noEmit": false
  },
  "include": ["vite.config.ts"]
}
--- END OF FILE tsconfig.node.json ---

--- START OF FILE vite.config.ts ---
import path from "path"
import react from "@vitejs/plugin-react"
import { defineConfig } from "vite"

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
})
--- END OF FILE vite.config.ts ---

--- START OF FILE src/index.css ---
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@keyframes blob {
	0% { transform: translate(0px, 0px) scale(1); }
	33% { transform: translate(30px, -50px) scale(1.1); }
	66% { transform: translate(-20px, 20px) scale(0.9); }
	100% { transform: translate(0px, 0px) scale(1); }
}

@keyframes shine {
  from { background-position: 100%; }
  to { background-position: -100%; }
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
  --font-sans: "Inter", system-ui, sans-serif;
  --animate-blob: blob 7s infinite;
  --animate-shine: shine 5s linear infinite;
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.21 0.006 285.885);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.705 0.015 286.067);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.21 0.006 285.885);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.705 0.015 286.067);
}

.dark {
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.92 0.004 286.32);
  --primary-foreground: oklch(0.21 0.006 285.885);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.552 0.016 285.938);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.552 0.016 285.938);
}


@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground font-sans;
  }
}
--- END OF FILE src/index.css ---

--- START OF FILE src/main.tsx ---
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { createBrowserRouter, RouterProvider } from 'react-router-dom';
import './index.css';

import { Layout } from '@/components/Layout';
import { HomePage } from '@/pages/HomePage';
import { tools } from '@/tools';
import { NotFoundPage } from '@/pages/NotFoundPage';

const router = createBrowserRouter([
  {
    path: '/',
    element: <Layout />,
    children: [
      {
        index: true,
        element: <HomePage />,
      },
      ...tools.map(tool => ({
        path: tool.path,
        element: <tool.component />,
      })),
      {
        path: '*',
        element: <NotFoundPage />,
      }
    ],
  },
]);

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);
--- END OF FILE src/main.tsx ---

--- START OF FILE src/tools.ts ---
import React from 'react';
import { QRCodeGenerator } from '@/pages/tools/QRCodeGenerator';
import { PlaceholderTool } from '@/pages/tools/PlaceholderTool';

export interface Tool {
    name: string;
    description: string;
    path: string;
    component: React.ComponentType;
}

const createPlaceholder = (toolName: string): React.ComponentType => {
    const PlaceholderComponent = () => React.createElement(PlaceholderTool, { toolName });
    PlaceholderComponent.displayName = `Placeholder(${toolName})`;
    return PlaceholderComponent;
};

export const tools: Tool[] = [
    {
        name: 'QR Code Generator',
        description: 'Create and customize a QR code.',
        path: '/tools/qr-code-generator',
        component: QRCodeGenerator,
    },
    {
        name: 'JSON Formatter',
        description: 'Beautify and validate your JSON data.',
        path: '/tools/json-formatter',
        component: createPlaceholder('JSON Formatter'),
    },
    {
        name: 'Color Converter',
        description: 'Convert colors between HEX, RGB, and HSL.',
        path: '/tools/color-converter',
        component: createPlaceholder('Color Converter'),
    },
    {
        name: 'Lorem Ipsum Generator',
        description: 'Generate placeholder text for your designs.',
        path: '/tools/lorem-ipsum-generator',
        component: createPlaceholder('Lorem Ipsum Generator'),
    },
    {
        name: 'Base64 Encoder',
        description: 'Encode and decode text to Base64.',
        path: '/tools/base64-encoder',
        component: createPlaceholder('Base64 Encoder'),
    },
];
--- END OF FILE src/tools.ts ---

--- START OF FILE src/components/ErrorBoundary.tsx ---
import { Component, ErrorInfo, ReactNode } from "react";

interface Props {
    children: ReactNode;
    fallback: ReactNode;
}

interface State {
    hasError: boolean;
}

class ErrorBoundary extends Component<Props, State> {
    public state: State = {
        hasError: false,
    };

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    public static getDerivedStateFromError(_: Error): State {
        // Update state so the next render will show the fallback UI.
        return { hasError: true };
    }

    public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        // You can also log the error to an error reporting service
        console.error("Uncaught error:", error, errorInfo);
    }

    public render() {
        if (this.state.hasError) {
            return this.props.fallback;
        }

        return this.props.children;
    }
}

export default ErrorBoundary;
--- END OF FILE src/components/ErrorBoundary.tsx ---

--- START OF FILE src/components/Layout.tsx ---
import { useState, useRef, useEffect } from 'react';
import { Outlet, useLocation, NavLink } from 'react-router-dom';
import { motion, AnimatePresence } from 'motion/react';
import { tools } from '@/tools';
import Beams from './bits/Beams';
import { StaggeredMenu, StaggeredMenuItem, StaggeredMenuSocialItem } from './bits/StaggeredMenu';
import { ClickSpark } from './bits/ClickSpark';
import { Home } from 'lucide-react';

export type LayoutContext = {
    openMenu: () => void;
};

export const Layout = () => {
    const location = useLocation();
    const isHomePage = location.pathname === '/';
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const mousePosition = useRef({ x: 0, y: 0 });
    const [showBeams, setShowBeams] = useState(isHomePage);
    const isInitialMount = useRef(true);

    useEffect(() => {
        if (isHomePage) {
            // On initial mount or navigation to homepage, reset and delay
            if (isInitialMount.current) {
                setShowBeams(false);
                isInitialMount.current = false;
            } else {
                setShowBeams(false);
            }

            const timer = setTimeout(() => {
                setShowBeams(true);
            }, 100);
            return () => clearTimeout(timer);
        } else {
            // Immediately hide beams when leaving homepage
            setShowBeams(false);
        }
    }, [isHomePage]);

    useEffect(() => {
        const handleMouseMove = (event: MouseEvent) => {
            mousePosition.current = { x: event.clientX, y: event.clientY };
        };
        window.addEventListener('mousemove', handleMouseMove);
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
        };
    }, []);

    const toggleMenu = () => setIsMenuOpen(prev => !prev);
    const openMenu = () => setIsMenuOpen(true);
    const closeMenu = () => setIsMenuOpen(false);

    const menuItems: StaggeredMenuItem[] = [
        {
            label: 'Home',
            ariaLabel: 'Go to Home page',
            link: '/',
        },
        ...tools.map(tool => ({
            label: tool.name,
            ariaLabel: `Go to ${tool.name}`,
            link: tool.path,
        })),
    ];

    const socialItems: StaggeredMenuSocialItem[] = [
        { label: 'GitHub', link: 'https://github.com/SoldatenEnte' },
        { label: 'Instagram', link: 'https://www.instagram.com/apos.tels/' },
    ];

    const logo = !isHomePage ? (
        <NavLink to="/" aria-label="Go to homepage" className="text-zinc-50 hover:text-white transition-all duration-200 ease-in-out hover:scale-110">
            <Home className="h-7 w-7" />
        </NavLink>
    ) : null;

    return (
        <div className="h-screen font-sans antialiased relative">
            <ClickSpark>
                {isHomePage && showBeams && (
                    <div
                        className="absolute inset-0 -z-10 transition-opacity duration-[2000ms] ease-in-out"
                        style={{ opacity: 1 }}
                    >
                        <Beams
                            beamWidth={3}
                            beamHeight={30}
                            beamNumber={60}
                            speed={2}
                            noiseIntensity={1.75}
                            scale={0.2}
                            rotation={30}
                            lightIntensity={0.4}
                            envMapIntensity={3}
                        />
                        <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,transparent_60%,black)] pointer-events-none" />
                    </div>
                )}

                <div className="relative z-10 h-full flex flex-col">
                    {/* Mobile top gradient for header contrast */}
                    <div className="absolute top-0 left-0 right-0 h-40 bg-gradient-to-b from-background/80 via-background/50 to-transparent pointer-events-none z-30 lg:hidden" />

                    <StaggeredMenu
                        items={menuItems}
                        socialItems={socialItems}
                        displaySocials={true}
                        isFixed={true}
                        colors={['#18181b', '#27272a']} // zinc-900, zinc-800
                        accentColor="#FAFAFA" // zinc-50
                        openMenuButtonColor="#FAFAFA"
                        isOpen={isMenuOpen}
                        onToggle={toggleMenu}
                        onClose={closeMenu}
                        initialCursorPos={mousePosition.current}
                        logo={logo}
                    />

                    <main className="flex-1 flex flex-col overflow-y-auto">
                        <AnimatePresence mode="wait">
                            <motion.div
                                key={location.pathname}
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 1 }}
                                exit={{ opacity: 0 }}
                                transition={{ duration: 0.15, ease: "easeOut" }}
                                className="flex-1 flex flex-col p-4 sm:p-6 lg:p-8 lg:pt-20 pt-20"
                            >
                                <Outlet context={{ openMenu }} />
                            </motion.div>
                        </AnimatePresence>
                    </main>
                </div>
            </ClickSpark>
        </div>
    );
};
--- END OF FILE src/components/Layout.tsx ---

--- START OF FILE src/components/PixelBlast.tsx ---
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { EffectComposer, EffectPass, RenderPass, Effect } from 'postprocessing';

type PixelBlastVariant = 'square' | 'circle' | 'triangle' | 'diamond';

type PixelBlastProps = {
  variant?: PixelBlastVariant;
  pixelSize?: number;
  color?: string;
  className?: string;
  style?: React.CSSProperties;
  antialias?: boolean;
  patternScale?: number;
  patternDensity?: number;
  liquid?: boolean;
  liquidStrength?: number;
  liquidRadius?: number;
  pixelSizeJitter?: number;
  enableRipples?: boolean;
  rippleIntensityScale?: number;
  rippleThickness?: number;
  rippleSpeed?: number;
  liquidWobbleSpeed?: number;
  autoPauseOffscreen?: boolean;
  speed?: number;
  transparent?: boolean;
  edgeFade?: number;
  noiseAmount?: number;
};

const createTouchTexture = () => {
  const size = 64;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  if (!ctx) throw new Error('2D context not available');
  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  const texture = new THREE.Texture(canvas);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.generateMipmaps = false;
  const trail: {
    x: number;
    y: number;
    vx: number;
    vy: number;
    force: number;
    age: number;
  }[] = [];
  let last: { x: number; y: number } | null = null;
  const maxAge = 64;
  let radius = 0.1 * size;
  const speed = 1 / maxAge;
  const clear = () => {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  };
  const drawPoint = (p: { x: number; y: number; vx: number; vy: number; force: number; age: number }) => {
    const pos = { x: p.x * size, y: (1 - p.y) * size };
    let intensity = 1;
    const easeOutSine = (t: number) => Math.sin((t * Math.PI) / 2);
    const easeOutQuad = (t: number) => -t * (t - 2);
    if (p.age < maxAge * 0.3) intensity = easeOutSine(p.age / (maxAge * 0.3));
    else intensity = easeOutQuad(1 - (p.age - maxAge * 0.3) / (maxAge * 0.7)) || 0;
    intensity *= p.force;
    const color = `${((p.vx + 1) / 2) * 255}, ${((p.vy + 1) / 2) * 255}, ${intensity * 255}`;
    const offset = size * 5;
    ctx.shadowOffsetX = offset;
    ctx.shadowOffsetY = offset;
    ctx.shadowBlur = radius;
    ctx.shadowColor = `rgba(${color},${0.22 * intensity})`;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,0,0,1)';
    ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);
    ctx.fill();
  };
  const addTouch = (norm: { x: number; y: number }) => {
    let force = 0;
    let vx = 0;
    let vy = 0;
    if (last) {
      const dx = norm.x - last.x;
      const dy = norm.y - last.y;
      if (dx === 0 && dy === 0) return;
      const dd = dx * dx + dy * dy;
      const d = Math.sqrt(dd);
      vx = dx / (d || 1);
      vy = dy / (d || 1);
      force = Math.min(dd * 10000, 1);
    }
    last = { x: norm.x, y: norm.y };
    trail.push({ x: norm.x, y: norm.y, age: 0, force, vx, vy });
  };
  const update = () => {
    clear();
    for (let i = trail.length - 1; i >= 0; i--) {
      const point = trail[i];
      const f = point.force * speed * (1 - point.age / maxAge);
      point.x += point.vx * f;
      point.y += point.vy * f;
      point.age++;
      if (point.age > maxAge) trail.splice(i, 1);
    }
    for (let i = 0; i < trail.length; i++) drawPoint(trail[i]);
    texture.needsUpdate = true;
  };
  return {
    canvas,
    texture,
    addTouch,
    update,
    set radiusScale(v: number) {
      radius = 0.1 * size * v;
    },
    get radiusScale() {
      return radius / (0.1 * size);
    },
    size
  };
};

const createLiquidEffect = (texture: THREE.Texture, opts?: { strength?: number; freq?: number }) => {
  const fragment = `
    uniform sampler2D uTexture;
    uniform float uStrength;
    uniform float uTime;
    uniform float uFreq;

    void mainUv(inout vec2 uv) {
      vec4 tex = texture2D(uTexture, uv);
      float vx = tex.r * 2.0 - 1.0;
      float vy = tex.g * 2.0 - 1.0;
      float intensity = tex.b;

      float wave = 0.5 + 0.5 * sin(uTime * uFreq + intensity * 6.2831853);

      float amt = uStrength * intensity * wave;

      uv += vec2(vx, vy) * amt;
    }
    `;
  return new Effect('LiquidEffect', fragment, {
    uniforms: new Map<string, THREE.Uniform>([
      ['uTexture', new THREE.Uniform(texture)],
      ['uStrength', new THREE.Uniform(opts?.strength ?? 0.025)],
      ['uTime', new THREE.Uniform(0)],
      ['uFreq', new THREE.Uniform(opts?.freq ?? 4.5)]
    ])
  });
};

const SHAPE_MAP: Record<PixelBlastVariant, number> = {
  square: 0,
  circle: 1,
  triangle: 2,
  diamond: 3
};

const VERTEX_SRC = `
void main() {
  gl_Position = vec4(position, 1.0);
}
`;

const FRAGMENT_SRC = `
precision highp float;

uniform vec3  uColor;
uniform vec2  uResolution;
uniform float uTime;
uniform float uPixelSize;
uniform float uScale;
uniform float uDensity;
uniform float uPixelJitter;
uniform int   uEnableRipples;
uniform float uRippleSpeed;
uniform float uRippleThickness;
uniform float uRippleIntensity;
uniform float uEdgeFade;

uniform int   uShapeType;
const int SHAPE_SQUARE   = 0;
const int SHAPE_CIRCLE   = 1;
const int SHAPE_TRIANGLE = 2;
const int SHAPE_DIAMOND  = 3;

const int   MAX_CLICKS = 10;

uniform vec2  uClickPos  [MAX_CLICKS];
uniform float uClickTimes[MAX_CLICKS];

out vec4 fragColor;

float Bayer2(vec2 a) {
  a = floor(a);
  return fract(a.x / 2. + a.y * a.y * .75);
}
#define Bayer4(a) (Bayer2(.5*(a))*0.25 + Bayer2(a))
#define Bayer8(a) (Bayer4(.5*(a))*0.25 + Bayer2(a))

#define FBM_OCTAVES     5
#define FBM_LACUNARITY  1.25
#define FBM_GAIN        1.0

float hash11(float n){ return fract(sin(n)*43758.5453); }

float vnoise(vec3 p){
  vec3 ip = floor(p);
  vec3 fp = fract(p);
  float n000 = hash11(dot(ip + vec3(0.0,0.0,0.0), vec3(1.0,57.0,113.0)));
  float n100 = hash11(dot(ip + vec3(1.0,0.0,0.0), vec3(1.0,57.0,113.0)));
  float n010 = hash11(dot(ip + vec3(0.0,1.0,0.0), vec3(1.0,57.0,113.0)));
  float n110 = hash11(dot(ip + vec3(1.0,1.0,0.0), vec3(1.0,57.0,113.0)));
  float n001 = hash11(dot(ip + vec3(0.0,0.0,1.0), vec3(1.0,57.0,113.0)));
  float n101 = hash11(dot(ip + vec3(1.0,0.0,1.0), vec3(1.0,57.0,113.0)));
  float n011 = hash11(dot(ip + vec3(0.0,1.0,1.0), vec3(1.0,57.0,113.0)));
  float n111 = hash11(dot(ip + vec3(1.0,1.0,1.0), vec3(1.0,57.0,113.0)));
  vec3 w = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);
  float x00 = mix(n000, n100, w.x);
  float x10 = mix(n010, n110, w.x);
  float x01 = mix(n001, n101, w.x);
  float x11 = mix(n011, n111, w.x);
  float y0  = mix(x00, x10, w.y);
  float y1  = mix(x01, x11, w.y);
  return mix(y0, y1, w.z) * 2.0 - 1.0;
}

float fbm2(vec2 uv, float t){
  vec3 p = vec3(uv * uScale, t);
  float amp = 1.0;
  float freq = 1.0;
  float sum = 1.0;
  for (int i = 0; i < FBM_OCTAVES; ++i){
    sum  += amp * vnoise(p * freq);
    freq *= FBM_LACUNARITY;
    amp  *= FBM_GAIN;
  }
  return sum * 0.5 + 0.5;
}

float maskCircle(vec2 p, float cov){
  float r = sqrt(cov) * .25;
  float d = length(p - 0.5) - r;
  float aa = 0.5 * fwidth(d);
  return cov * (1.0 - smoothstep(-aa, aa, d * 2.0));
}

float maskTriangle(vec2 p, vec2 id, float cov){
  bool flip = mod(id.x + id.y, 2.0) > 0.5;
  if (flip) p.x = 1.0 - p.x;
  float r = sqrt(cov);
  float d  = p.y - r*(1.0 - p.x);
  float aa = fwidth(d);
  return cov * clamp(0.5 - d/aa, 0.0, 1.0);
}

float maskDiamond(vec2 p, float cov){
  float r = sqrt(cov) * 0.564;
  return step(abs(p.x - 0.49) + abs(p.y - 0.49), r);
}

void main(){
  float pixelSize = uPixelSize;
  vec2 fragCoord = gl_FragCoord.xy - uResolution * .5;
  float aspectRatio = uResolution.x / uResolution.y;

  vec2 pixelId = floor(fragCoord / pixelSize);
  vec2 pixelUV = fract(fragCoord / pixelSize);

  float cellPixelSize = 8.0 * pixelSize;
  vec2 cellId = floor(fragCoord / cellPixelSize);
  vec2 cellCoord = cellId * cellPixelSize;
  vec2 uv = cellCoord / uResolution * vec2(aspectRatio, 1.0);

  float base = fbm2(uv, uTime * 0.05);
  base = base * 0.5 - 0.65;

  float feed = base + (uDensity - 0.5) * 0.3;

  float speed     = uRippleSpeed;
  float thickness = uRippleThickness;
  const float dampT     = 1.0;
  const float dampR     = 10.0;

  if (uEnableRipples == 1) {
    for (int i = 0; i < MAX_CLICKS; ++i){
      vec2 pos = uClickPos[i];
      if (pos.x < 0.0) continue;
      float cellPixelSize = 8.0 * pixelSize;
      vec2 cuv = (((pos - uResolution * .5 - cellPixelSize * .5) / (uResolution))) * vec2(aspectRatio, 1.0);
      float t = max(uTime - uClickTimes[i], 0.0);
      float r = distance(uv, cuv);
      float waveR = speed * t;
      float ring  = exp(-pow((r - waveR) / thickness, 2.0));
      float atten = exp(-dampT * t) * exp(-dampR * r);
      feed = max(feed, ring * atten * uRippleIntensity);
    }
  }

  float bayer = Bayer8(fragCoord / uPixelSize) - 0.5;
  float bw = step(0.5, feed + bayer);

  float h = fract(sin(dot(floor(fragCoord / uPixelSize), vec2(127.1, 311.7))) * 43758.5453);
  float jitterScale = 1.0 + (h - 0.5) * uPixelJitter;
  float coverage = bw * jitterScale;
  float M;
  if      (uShapeType == SHAPE_CIRCLE)   M = maskCircle (pixelUV, coverage);
  else if (uShapeType == SHAPE_TRIANGLE) M = maskTriangle(pixelUV, pixelId, coverage);
  else if (uShapeType == SHAPE_DIAMOND)  M = maskDiamond(pixelUV, coverage);
  else                                   M = coverage;

  if (uEdgeFade > 0.0) {
    vec2 norm = gl_FragCoord.xy / uResolution;
    float edge = min(min(norm.x, norm.y), min(1.0 - norm.x, 1.0 - norm.y));
    float fade = smoothstep(0.0, uEdgeFade, edge);
    M *= fade;
  }

  vec3 color = uColor;
  fragColor = vec4(color, M);
}
`;

const MAX_CLICKS = 10;

const PixelBlast: React.FC<PixelBlastProps> = ({
  variant = 'square',
  pixelSize = 3,
  color = '#B19EEF',
  className,
  style,
  antialias = true,
  patternScale = 2,
  patternDensity = 1,
  liquid = false,
  liquidStrength = 0.1,
  liquidRadius = 1,
  pixelSizeJitter = 0,
  enableRipples = true,
  rippleIntensityScale = 1,
  rippleThickness = 0.1,
  rippleSpeed = 0.3,
  liquidWobbleSpeed = 4.5,
  autoPauseOffscreen = true,
  speed = 0.5,
  transparent = true,
  edgeFade = 0.5,
  noiseAmount = 0
}) => {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const visibilityRef = useRef({ visible: true });
  const speedRef = useRef(speed);

  const threeRef = useRef<{
    renderer: THREE.WebGLRenderer;
    scene: THREE.Scene;
    camera: THREE.OrthographicCamera;
    material: THREE.ShaderMaterial;
    clock: THREE.Clock;
    clickIx: number;
    uniforms: {
      uResolution: { value: THREE.Vector2 };
      uTime: { value: number };
      uColor: { value: THREE.Color };
      uClickPos: { value: THREE.Vector2[] };
      uClickTimes: { value: Float32Array };
      uShapeType: { value: number };
      uPixelSize: { value: number };
      uScale: { value: number };
      uDensity: { value: number };
      uPixelJitter: { value: number };
      uEnableRipples: { value: number };
      uRippleSpeed: { value: number };
      uRippleThickness: { value: number };
      uRippleIntensity: { value: number };
      uEdgeFade: { value: number };
    };
    resizeObserver?: ResizeObserver;
    raf?: number;
    quad?: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>;
    timeOffset?: number;
    composer?: EffectComposer;
    touch?: ReturnType<typeof createTouchTexture>;
    liquidEffect?: Effect;
  } | null>(null);
  const prevConfigRef = useRef<any>(null);
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;
    speedRef.current = speed;
    const needsReinitKeys = ['antialias', 'liquid', 'noiseAmount'];
    const cfg = { antialias, liquid, noiseAmount };
    let mustReinit = false;
    if (!threeRef.current) mustReinit = true;
    else if (prevConfigRef.current) {
      for (const k of needsReinitKeys)
        if (prevConfigRef.current[k] !== (cfg as any)[k]) {
          mustReinit = true;
          break;
        }
    }
    if (mustReinit) {
      if (threeRef.current) {
        const t = threeRef.current;
        t.resizeObserver?.disconnect();
        cancelAnimationFrame(t.raf!);
        t.quad?.geometry.dispose();
        t.material.dispose();
        t.composer?.dispose();
        t.renderer.dispose();
        if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);
        threeRef.current = null;
      }
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl2', { antialias, alpha: true });
      if (!gl) return;
      const renderer = new THREE.WebGLRenderer({
        canvas,
        context: gl as WebGL2RenderingContext,
        antialias,
        alpha: true
      });
      renderer.domElement.style.width = '100%';
      renderer.domElement.style.height = '100%';
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      container.appendChild(renderer.domElement);
      const uniforms = {
        uResolution: { value: new THREE.Vector2(0, 0) },
        uTime: { value: 0 },
        uColor: { value: new THREE.Color(color) },
        uClickPos: {
          value: Array.from({ length: MAX_CLICKS }, () => new THREE.Vector2(-1, -1))
        },
        uClickTimes: { value: new Float32Array(MAX_CLICKS) },
        uShapeType: { value: SHAPE_MAP[variant] ?? 0 },
        uPixelSize: { value: pixelSize * renderer.getPixelRatio() },
        uScale: { value: patternScale },
        uDensity: { value: patternDensity },
        uPixelJitter: { value: pixelSizeJitter },
        uEnableRipples: { value: enableRipples ? 1 : 0 },
        uRippleSpeed: { value: rippleSpeed },
        uRippleThickness: { value: rippleThickness },
        uRippleIntensity: { value: rippleIntensityScale },
        uEdgeFade: { value: edgeFade }
      };
      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      const material = new THREE.ShaderMaterial({
        vertexShader: VERTEX_SRC,
        fragmentShader: FRAGMENT_SRC,
        uniforms,
        transparent: true,
        glslVersion: THREE.GLSL3,
        depthTest: false,
        depthWrite: false
      });
      const quadGeom = new THREE.PlaneGeometry(2, 2);
      const quad = new THREE.Mesh(quadGeom, material);
      scene.add(quad);
      const clock = new THREE.Clock();
      const setSize = () => {
        const w = container.clientWidth || 1;
        const h = container.clientHeight || 1;
        renderer.setSize(w, h, false);
        uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);
        if (threeRef.current?.composer)
          threeRef.current.composer.setSize(renderer.domElement.width, renderer.domElement.height);
        uniforms.uPixelSize.value = pixelSize * renderer.getPixelRatio();
      };
      setSize();
      const ro = new ResizeObserver(setSize);
      ro.observe(container);
      const randomFloat = () => {
        if (typeof window !== 'undefined' && (window as any).crypto?.getRandomValues) {
          const u32 = new Uint32Array(1);
          window.crypto.getRandomValues(u32);
          return u32[0] / 0xffffffff;
        }
        return Math.random();
      };
      const timeOffset = randomFloat() * 1000;
      let composer: EffectComposer | undefined;
      let touch: ReturnType<typeof createTouchTexture> | undefined;
      let liquidEffect: Effect | undefined;
      if (liquid) {
        touch = createTouchTexture();
        touch.radiusScale = liquidRadius;
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        liquidEffect = createLiquidEffect(touch.texture, {
          strength: liquidStrength,
          freq: liquidWobbleSpeed
        });
        const effectPass = new EffectPass(camera, liquidEffect);
        effectPass.renderToScreen = true;
        composer.addPass(renderPass);
        composer.addPass(effectPass);
      }
      if (noiseAmount > 0) {
        if (!composer) {
          composer = new EffectComposer(renderer);
          composer.addPass(new RenderPass(scene, camera));
        }
        const noiseEffect = new Effect(
          'NoiseEffect',
          `uniform float uTime; uniform float uAmount; float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);} void mainUv(inout vec2 uv){} void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){ float n=hash(floor(uv*vec2(1920.0,1080.0))+floor(uTime*60.0)); float g=(n-0.5)*uAmount; outputColor=inputColor+vec4(vec3(g),0.0);} `,
          {
            uniforms: new Map<string, THREE.Uniform>([
              ['uTime', new THREE.Uniform(0)],
              ['uAmount', new THREE.Uniform(noiseAmount)]
            ])
          }
        );
        const noisePass = new EffectPass(camera, noiseEffect);
        noisePass.renderToScreen = true;
        if (composer && composer.passes.length > 0) composer.passes.forEach(p => ((p as any).renderToScreen = false));
        composer.addPass(noisePass);
      }
      if (composer) composer.setSize(renderer.domElement.width, renderer.domElement.height);
      const mapToPixels = (e: PointerEvent) => {
        const rect = renderer.domElement.getBoundingClientRect();
        const scaleX = renderer.domElement.width / rect.width;
        const scaleY = renderer.domElement.height / rect.height;
        const fx = (e.clientX - rect.left) * scaleX;
        const fy = (rect.height - (e.clientY - rect.top)) * scaleY;
        return {
          fx,
          fy,
          w: renderer.domElement.width,
          h: renderer.domElement.height
        };
      };
      const onPointerDown = (e: PointerEvent) => {
        const { fx, fy } = mapToPixels(e);
        const ix = threeRef.current?.clickIx ?? 0;
        uniforms.uClickPos.value[ix].set(fx, fy);
        uniforms.uClickTimes.value[ix] = uniforms.uTime.value;
        if (threeRef.current) threeRef.current.clickIx = (ix + 1) % MAX_CLICKS;
      };
      const onPointerMove = (e: PointerEvent) => {
        if (!touch) return;
        const { fx, fy, w, h } = mapToPixels(e);
        touch.addTouch({ x: fx / w, y: fy / h });
      };
      renderer.domElement.addEventListener('pointerdown', onPointerDown, {
        passive: true
      });
      renderer.domElement.addEventListener('pointermove', onPointerMove, {
        passive: true
      });
      let raf = 0;
      const animate = () => {
        if (autoPauseOffscreen && !visibilityRef.current.visible) {
          raf = requestAnimationFrame(animate);
          return;
        }
        uniforms.uTime.value = timeOffset + clock.getElapsedTime() * speedRef.current;
        if (liquidEffect) (liquidEffect as any).uniforms.get('uTime').value = uniforms.uTime.value;
        if (composer) {
          if (touch) touch.update();
          composer.passes.forEach(p => {
            const effs = (p as any).effects;
            if (effs)
              effs.forEach((eff: any) => {
                const u = eff.uniforms?.get('uTime');
                if (u) u.value = uniforms.uTime.value;
              });
          });
          composer.render();
        } else renderer.render(scene, camera);
        raf = requestAnimationFrame(animate);
      };
      raf = requestAnimationFrame(animate);
      threeRef.current = {
        renderer,
        scene,
        camera,
        material,
        clock,
        clickIx: 0,
        uniforms,
        resizeObserver: ro,
        raf,
        quad,
        timeOffset,
        composer,
        touch,
        liquidEffect
      };
    } else {
      const t = threeRef.current!;
      t.uniforms.uShapeType.value = SHAPE_MAP[variant] ?? 0;
      t.uniforms.uPixelSize.value = pixelSize * t.renderer.getPixelRatio();
      t.uniforms.uColor.value.set(color);
      t.uniforms.uScale.value = patternScale;
      t.uniforms.uDensity.value = patternDensity;
      t.uniforms.uPixelJitter.value = pixelSizeJitter;
      t.uniforms.uEnableRipples.value = enableRipples ? 1 : 0;
      t.uniforms.uRippleIntensity.value = rippleIntensityScale;
      t.uniforms.uRippleThickness.value = rippleThickness;
      t.uniforms.uRippleSpeed.value = rippleSpeed;
      t.uniforms.uEdgeFade.value = edgeFade;
      if (transparent) t.renderer.setClearAlpha(0);
      else t.renderer.setClearColor(0x000000, 1);
      if (t.liquidEffect) {
        const uStrength = (t.liquidEffect as any).uniforms.get('uStrength');
        if (uStrength) uStrength.value = liquidStrength;
        const uFreq = (t.liquidEffect as any).uniforms.get('uFreq');
        if (uFreq) uFreq.value = liquidWobbleSpeed;
      }
      if (t.touch) t.touch.radiusScale = liquidRadius;
    }
    prevConfigRef.current = cfg;
    return () => {
      if (threeRef.current && mustReinit) return;
      if (!threeRef.current) return;
      const t = threeRef.current;
      t.resizeObserver?.disconnect();
      cancelAnimationFrame(t.raf!);
      t.quad?.geometry.dispose();
      t.material.dispose();
      t.composer?.dispose();
      t.renderer.dispose();
      if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);
      threeRef.current = null;
    };
  }, [
    antialias,
    liquid,
    noiseAmount,
    pixelSize,
    patternScale,
    patternDensity,
    enableRipples,
    rippleIntensityScale,
    rippleThickness,
    rippleSpeed,
    pixelSizeJitter,
    edgeFade,
    transparent,
    liquidStrength,
    liquidRadius,
    liquidWobbleSpeed,
    autoPauseOffscreen,
    variant,
    color,
    speed
  ]);

  return (
    <div
      ref={containerRef}
      className={`w-full h-full relative overflow-hidden ${className ?? ''}`}
      style={style}
      aria-label="PixelBlast interactive background"
    />
  );
};

export default PixelBlast;

--- END OF FILE src/components/PixelBlast.tsx ---

--- START OF FILE src/components/bits/Beams.tsx ---
import { forwardRef, useImperativeHandle, useEffect, useRef, useMemo, FC, ReactNode } from 'react';
import * as THREE from 'three';
import { Canvas, useFrame } from '@react-three/fiber';
import { PerspectiveCamera } from '@react-three/drei';
import { degToRad } from 'three/src/math/MathUtils.js';

type UniformValue = THREE.IUniform<unknown> | unknown;
interface ExtendMaterialConfig {
    header: string;
    vertexHeader?: string;
    fragmentHeader?: string;
    material?: THREE.MeshPhysicalMaterialParameters & { fog?: boolean };
    uniforms?: Record<string, UniformValue>;
    vertex?: Record<string, string>;
    fragment?: Record<string, string>;
}
type ShaderWithDefines = THREE.ShaderLibShader & { defines?: Record<string, string | number | boolean>; };

function extendMaterial<T extends THREE.Material = THREE.Material>(BaseMaterial: new (params?: THREE.MaterialParameters) => T, cfg: ExtendMaterialConfig): THREE.ShaderMaterial {
    const physical = THREE.ShaderLib.physical as ShaderWithDefines;
    const { vertexShader: baseVert, fragmentShader: baseFrag, uniforms: baseUniforms } = physical;
    const baseDefines = physical.defines ?? {};
    const uniforms: Record<string, THREE.IUniform> = THREE.UniformsUtils.clone(baseUniforms);
    const defaults = new BaseMaterial(cfg.material || {}) as T & { color?: THREE.Color; roughness?: number; metalness?: number; envMap?: THREE.Texture; envMapIntensity?: number; };
    if (defaults.color) uniforms.diffuse.value = defaults.color;
    if ('roughness' in defaults) uniforms.roughness.value = defaults.roughness;
    if ('metalness' in defaults) uniforms.metalness.value = defaults.metalness;
    if ('envMap' in defaults) uniforms.envMap.value = defaults.envMap;
    if ('envMapIntensity' in defaults) uniforms.envMapIntensity.value = defaults.envMapIntensity;
    Object.entries(cfg.uniforms ?? {}).forEach(([key, u]) => {
        uniforms[key] = u !== null && typeof u === 'object' && 'value' in u ? (u as THREE.IUniform<unknown>) : ({ value: u } as THREE.IUniform<unknown>);
    });
    let vert = `${cfg.header}\n${cfg.vertexHeader ?? ''}\n${baseVert}`;
    let frag = `${cfg.header}\n${cfg.fragmentHeader ?? ''}\n${baseFrag}`;
    for (const [inc, code] of Object.entries(cfg.vertex ?? {})) { vert = vert.replace(inc, `${inc}\n${code}`); }
    for (const [inc, code] of Object.entries(cfg.fragment ?? {})) { frag = frag.replace(inc, `${inc}\n${code}`); }
    const mat = new THREE.ShaderMaterial({ defines: { ...baseDefines }, uniforms, vertexShader: vert, fragmentShader: frag, lights: true, fog: !!cfg.material?.fog });
    return mat;
}

const CanvasWrapper: FC<{ children: ReactNode }> = ({ children }) => (
    <Canvas dpr={[1, 2]} frameloop="always" className="w-full h-full">
        {children}
    </Canvas>
);

const hexToNormalizedRGB = (hex: string): [number, number, number] => {
    const clean = hex.replace('#', '');
    const r = parseInt(clean.substring(0, 2), 16);
    const g = parseInt(clean.substring(2, 4), 16);
    const b = parseInt(clean.substring(4, 6), 16);
    return [r / 255, g / 255, b / 255];
};

const noise = `
float random (in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); }
float noise (in vec2 st) {
    vec2 i = floor(st); vec2 f = fract(st);
    float a = random(i); float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
float cnoise(vec3 P){
  vec3 Pi0 = floor(P); vec3 Pi1 = Pi0 + vec3(1.0);
  Pi0 = mod(Pi0, 289.0); Pi1 = mod(Pi1, 289.0);
  vec3 Pf0 = fract(P); vec3 Pf1 = Pf0 - vec3(1.0);
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz; vec4 iz1 = Pi1.zzzz;
  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1);
  vec4 gx0 = ixy0 / 7.0; vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
  gx0 = fract(gx0); vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
  vec4 gx1 = ixy1 / 7.0; vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
  gx1 = fract(gx1); vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x); vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z); vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x); vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z); vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
  vec4 norm0 = taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));
  g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));
  g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w;
  float n000 = dot(g000, Pf0); float n100 = dot(g100, vec3(Pf1.x,Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x,Pf1.y,Pf0.z)); float n110 = dot(g110, vec3(Pf1.xy,Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy,Pf1.z)); float n101 = dot(g101, vec3(Pf1.x,Pf0.y,Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x,Pf1.yz)); float n111 = dot(g111, Pf1);
  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);
  vec2 n_yz = mix(n_z.xy,n_z.zw,fade_xyz.y);
  float n_xyz = mix(n_yz.x,n_yz.y,fade_xyz.x);
  return 2.2 * n_xyz;
}`;
interface BeamsProps {
    beamWidth?: number; beamHeight?: number; beamNumber?: number;
    lightColor?: string; speed?: number; noiseIntensity?: number;
    scale?: number; rotation?: number;
    lightIntensity?: number; envMapIntensity?: number;
}
const Beams: FC<BeamsProps> = ({
    beamWidth = 2, beamHeight = 15, beamNumber = 12,
    lightColor = '#ffffff', speed = 2, noiseIntensity = 1.75,
    scale = 0.2, rotation = 0, lightIntensity = 1, envMapIntensity = 10
}) => {
    const meshRef = useRef<THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>>(null!);
    const beamMaterial = useMemo(() =>
        extendMaterial(THREE.MeshStandardMaterial, {
            header: `varying vec3 vEye; varying float vNoise; varying vec2 vUv; varying vec3 vPosition;
        uniform float time; uniform float uSpeed; uniform float uNoiseIntensity; uniform float uScale; ${noise}`,
            vertexHeader: `
        float getPos(vec3 pos) {
          vec3 noisePos = vec3(pos.x * 0., pos.y - uv.y, pos.z + time * uSpeed * 3.) * uScale;
          return cnoise(noisePos);
        }
        vec3 getCurrentPos(vec3 pos) {
          vec3 newpos = pos; newpos.z += getPos(pos); return newpos;
        }
        vec3 getNormal(vec3 pos) {
          vec3 curpos = getCurrentPos(pos); vec3 nextposX = getCurrentPos(pos + vec3(0.01, 0.0, 0.0));
          vec3 nextposZ = getCurrentPos(pos + vec3(0.0, -0.01, 0.0));
          vec3 tangentX = normalize(nextposX - curpos); vec3 tangentZ = normalize(nextposZ - curpos);
          return normalize(cross(tangentZ, tangentX));
        }`,
            vertex: {
                '#include <begin_vertex>': `transformed.z += getPos(transformed.xyz);`,
                '#include <beginnormal_vertex>': `objectNormal = getNormal(position.xyz);`
            },
            fragment: {
                '#include <dithering_fragment>': `float randomNoise = noise(gl_FragCoord.xy); gl_FragColor.rgb -= randomNoise / 15. * uNoiseIntensity;`
            },
            material: { fog: true },
            uniforms: {
                diffuse: new THREE.Color(...hexToNormalizedRGB('#000000')), time: { shared: true, mixed: true, linked: true, value: 0 },
                roughness: 0.3, metalness: 0.3, uSpeed: { shared: true, mixed: true, linked: true, value: speed },
                envMapIntensity: envMapIntensity, uNoiseIntensity: noiseIntensity, uScale: scale
            }
        }), [speed, noiseIntensity, scale, envMapIntensity]
    );

    return (
        <CanvasWrapper>
            <group rotation={[0, 0, degToRad(rotation)]}>
                <MergedPlanes ref={meshRef} material={beamMaterial} count={beamNumber} width={beamWidth} height={beamHeight} />
                <DirLight color={lightColor} position={[0, 3, 10]} intensity={lightIntensity} />
            </group>
            <ambientLight intensity={1} />
            <color attach="background" args={['#000000']} />
            <PerspectiveCamera makeDefault position={[0, 0, 20]} fov={30} />
        </CanvasWrapper>
    );
};
function createStackedPlanesBufferGeometry(n: number, width: number, height: number, spacing: number, heightSegments: number): THREE.BufferGeometry {
    const geometry = new THREE.BufferGeometry();
    const numVertices = n * (heightSegments + 1) * 2; const numFaces = n * heightSegments * 2;
    const positions = new Float32Array(numVertices * 3); const indices = new Uint32Array(numFaces * 3);
    const uvs = new Float32Array(numVertices * 2);
    let vertexOffset = 0, indexOffset = 0, uvOffset = 0;
    const totalWidth = n * width + (n - 1) * spacing; const xOffsetBase = -totalWidth / 2;
    for (let i = 0; i < n; i++) {
        const xOffset = xOffsetBase + i * (width + spacing);
        const uvXOffset = Math.random() * 300, uvYOffset = Math.random() * 300;
        for (let j = 0; j <= heightSegments; j++) {
            const y = height * (j / heightSegments - 0.5); const v0 = [xOffset, y, 0], v1 = [xOffset + width, y, 0];
            positions.set([...v0, ...v1], vertexOffset * 3);
            const uvY = j / heightSegments; uvs.set([uvXOffset, uvY + uvYOffset, uvXOffset + 1, uvY + uvYOffset], uvOffset);
            if (j < heightSegments) {
                const a = vertexOffset, b = vertexOffset + 1, c = vertexOffset + 2, d = vertexOffset + 3;
                indices.set([a, b, c, c, b, d], indexOffset); indexOffset += 6;
            }
            vertexOffset += 2; uvOffset += 4;
        }
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    geometry.computeVertexNormals();
    return geometry;
}
const MergedPlanes = forwardRef<THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>, { material: THREE.ShaderMaterial; width: number; count: number; height: number; }>
    (({ material, width, count, height }, ref) => {
        const mesh = useRef<THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>>(null!);
        useImperativeHandle(ref, () => mesh.current);
        const geometry = useMemo(() => createStackedPlanesBufferGeometry(count, width, height, 0, 100), [count, width, height]);
        useFrame((_, delta) => { mesh.current.material.uniforms.time.value += 0.1 * delta; });
        return <mesh ref={mesh} geometry={geometry} material={material} />;
    });
MergedPlanes.displayName = 'MergedPlanes';
const DirLight: FC<{ position: [number, number, number]; color: string; intensity?: number }> = ({ position, color, intensity = 1 }) => {
    const dir = useRef<THREE.DirectionalLight>(null!);
    useEffect(() => {
        if (!dir.current) return;
        const cam = dir.current.shadow.camera as THREE.Camera & { top: number; bottom: number; left: number; right: number; far: number; };
        cam.top = 24; cam.bottom = -24; cam.left = -24; cam.right = 24; cam.far = 64;
        dir.current.shadow.bias = -0.004;
    }, []);
    return <directionalLight ref={dir} color={color} intensity={intensity} position={position} />;
};

export default Beams;
--- END OF FILE src/components/bits/Beams.tsx ---

--- START OF FILE src/components/bits/CircularText.tsx ---
import React, { useEffect, useState, useRef } from 'react';
import { motion, useAnimation, useMotionValue, MotionValue, Transition, useSpring } from 'motion/react';
import { ArrowUpRight } from 'lucide-react';

interface CircularTextProps {
    text: string;
    href: string;
    spinDuration?: number;
    onHover?: 'slowDown' | 'speedUp' | 'pause' | 'goBonkers';
    className?: string;
}

const getRotationTransition = (duration: number, from: number, loop: boolean = true) => ({
    from,
    to: from + 360,
    ease: 'linear' as const,
    duration,
    type: 'tween' as const,
    repeat: loop ? Infinity : 0
});

const getTransition = (duration: number, from: number) => ({
    rotate: getRotationTransition(duration, from),
    scale: {
        type: 'spring' as const,
        damping: 20,
        stiffness: 300
    }
});

const CircularText: React.FC<CircularTextProps> = ({
    text,
    href,
    spinDuration = 20,
    onHover = 'speedUp',
    className = ''
}) => {
    const letters = Array.from(text);
    const controls = useAnimation();
    const rotation: MotionValue<number> = useMotionValue(0);
    const [isHovered, setIsHovered] = useState(false);

    const ref = useRef<HTMLAnchorElement>(null);
    const magneticX = useMotionValue(0);
    const magneticY = useMotionValue(0);

    const springConfig = { damping: 40, stiffness: 300, mass: 1 };
    const springX = useSpring(magneticX, springConfig);
    const springY = useSpring(magneticY, springConfig);

    useEffect(() => {
        const el = ref.current;
        if (!el) return;

        const handleMouseMove = (e: MouseEvent) => {
            const { clientX, clientY } = e;
            const { left, top, width, height } = el.getBoundingClientRect();

            const centerX = left + width / 2;
            const centerY = top + height / 2;

            const deltaX = clientX - centerX;
            const deltaY = clientY - centerY;

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const magneticRadius = 250;
            const maxPullStrength = 0.4;

            if (distance < magneticRadius) {
                const pullFactor = 1 - distance / magneticRadius;
                magneticX.set(deltaX * maxPullStrength * pullFactor);
                magneticY.set(deltaY * maxPullStrength * pullFactor);
            } else {
                magneticX.set(0);
                magneticY.set(0);
            }
        };

        window.addEventListener('mousemove', handleMouseMove);

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
        };
    }, [magneticX, magneticY]);

    useEffect(() => {
        const start = rotation.get();
        controls.start({
            rotate: start + 360,
            scale: 1,
            transition: getTransition(spinDuration, start)
        });
    }, [spinDuration, text, onHover, controls, rotation]);

    const handleHoverStart = () => {
        setIsHovered(true);
        const start = rotation.get();

        if (!onHover) return;

        let transitionConfig: ReturnType<typeof getTransition> | Transition;
        let scaleVal = 1;

        switch (onHover) {
            case 'slowDown':
                transitionConfig = getTransition(spinDuration * 2, start);
                break;
            case 'speedUp':
                transitionConfig = getTransition(spinDuration / 4, start);
                break;
            case 'pause':
                controls.stop();
                return;
            case 'goBonkers':
                transitionConfig = getTransition(spinDuration / 20, start);
                scaleVal = 0.8;
                break;
            default:
                transitionConfig = getTransition(spinDuration, start);
        }

        controls.start({
            rotate: start + 360,
            scale: scaleVal,
            transition: transitionConfig
        });
    };

    const handleHoverEnd = () => {
        setIsHovered(false);
        const start = rotation.get();
        controls.start({
            rotate: start + 360,
            scale: 1,
            transition: getTransition(spinDuration, start)
        });
    };

    const innerCircleVariants = {
        hidden: { opacity: 0, scale: 0 },
        visible: { opacity: 1, scale: 1 }
    };

    return (
        <motion.a
            ref={ref}
            href={href}
            target="_blank"
            rel="noopener noreferrer"
            className="block"
            style={{ x: springX, y: springY }}
        >
            <motion.div
                className={`m-0 mx-auto rounded-full w-[120px] h-[120px] relative font-black text-white text-center cursor-pointer origin-center flex items-center justify-center ${className}`}
                onHoverStart={handleHoverStart}
                onHoverEnd={handleHoverEnd}
            >
                <motion.div
                    className="absolute w-[60%] h-[60%] bg-white rounded-full flex items-center justify-center"
                    variants={innerCircleVariants}
                    initial="hidden"
                    animate={isHovered ? "visible" : "hidden"}
                    transition={{ type: 'spring', stiffness: 400, damping: 25 }}
                >
                    <ArrowUpRight className="text-black h-8 w-8" />
                </motion.div>

                <motion.div
                    className="absolute w-full h-full"
                    style={{ rotate: rotation }}
                    animate={controls}
                >
                    {letters.map((letter, i) => {
                        const angle = (i / letters.length) * 360;
                        return (
                            <span
                                key={i}
                                className="absolute top-0 left-1/2 -translate-x-1/2 h-1/2 origin-bottom text-sm"
                                style={{ transform: `rotate(${angle}deg)` }}
                            >
                                {letter}
                            </span>
                        );
                    })}
                </motion.div>
            </motion.div>
        </motion.a>
    );
};

export default CircularText;
--- END OF FILE src/components/bits/CircularText.tsx ---

--- START OF FILE src/components/bits/ClickSpark.tsx ---
import React, { useRef, useEffect, useCallback } from 'react';

interface Spark { x: number; y: number; angle: number; startTime: number; }

export const ClickSpark: React.FC<{ children?: React.ReactNode }> = ({ children }) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const sparksRef = useRef<Spark[]>([]);
    const sparkColor = '#fff'; const sparkSize = 2; const sparkRadius = 25;
    const sparkCount = 12; const duration = 500;

    // FIX: Explicitly define the type for `easing` to allow for all possible string values.
    const easing: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out' = 'ease-out';

    useEffect(() => {
        const canvas = canvasRef.current; if (!canvas) return;
        const parent = canvas.parentElement; if (!parent) return;
        let resizeTimeout: NodeJS.Timeout;
        const resizeCanvas = () => {
            const { width, height } = parent.getBoundingClientRect();
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width; canvas.height = height;
            }
        };
        const handleResize = () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(resizeCanvas, 100); };
        const ro = new ResizeObserver(handleResize); ro.observe(parent);
        resizeCanvas();
        return () => { ro.disconnect(); clearTimeout(resizeTimeout); };
    }, []);

    const easeFunc = useCallback((t: number) => {
        switch (easing as string) {
            case 'ease-in': return t * t;
            case 'ease-in-out': return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            case 'linear': return t;
            case 'ease-out':
            default: return t * (2 - t);
        }
    }, [easing]);

    useEffect(() => {
        const canvas = canvasRef.current; if (!canvas) return;
        const ctx = canvas.getContext('2d'); if (!ctx) return;
        let animationId: number;
        const draw = (timestamp: number) => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            sparksRef.current = sparksRef.current.filter(spark => {
                const elapsed = timestamp - spark.startTime;
                if (elapsed >= duration) return false;
                const progress = elapsed / duration; const eased = easeFunc(progress);
                const distance = eased * sparkRadius;
                const lineLength = sparkSize * (1 - eased);
                const x1 = spark.x + distance * Math.cos(spark.angle); const y1 = spark.y + distance * Math.sin(spark.angle);
                const x2 = spark.x + (distance + lineLength) * Math.cos(spark.angle); const y2 = spark.y + (distance + lineLength) * Math.sin(spark.angle);
                ctx.strokeStyle = sparkColor; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                return true;
            });
            animationId = requestAnimationFrame(draw);
        };
        animationId = requestAnimationFrame(draw);
        return () => cancelAnimationFrame(animationId);
    }, [easeFunc]);

    const handleClick = (e: React.MouseEvent<HTMLDivElement>): void => {
        const canvas = canvasRef.current; if (!canvas) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left; const y = e.clientY - rect.top;
        const now = performance.now();
        const newSparks: Spark[] = Array.from({ length: sparkCount }, (_, i) => ({ x, y, angle: (2 * Math.PI * i) / sparkCount, startTime: now }));
        sparksRef.current.push(...newSparks);
    };

    return (
        <div className="relative w-full h-full" onClick={handleClick}>
            <canvas ref={canvasRef} className="absolute inset-0 pointer-events-none" />
            {children}
        </div>
    );
};
--- END OF FILE src/components/bits/ClickSpark.tsx ---

--- START OF FILE src/components/bits/Dock.tsx ---
import { motion, MotionValue, useMotionValue, useSpring, useTransform, AnimatePresence } from 'motion/react';
import React, { Children, cloneElement, useEffect, useRef, useState } from 'react';
import { NavLink } from 'react-router-dom';

export type DockItemData = {
    id: string;
    icon: React.ReactNode;
    label: string;
    path: string;
};

export type DockProps = {
    items: DockItemData[];
    className?: string;
};

type DockItemProps = {
    children: React.ReactNode;
    path: string;
    mouseX: MotionValue<number>;
};

function DockItem({ children, path, mouseX }: DockItemProps) {
    const ref = useRef<HTMLAnchorElement>(null);
    const isHovered = useMotionValue(0);
    const distance = useTransform(mouseX, val => {
        const bounds = ref.current?.getBoundingClientRect() ?? { x: 0, width: 0 };
        return val - bounds.x - bounds.width / 2;
    });
    const width = useTransform(distance, [-100, 0, 100], [50, 100, 50]);
    const widthSync = useSpring(width, { mass: 0.1, stiffness: 150, damping: 12 });

    return (
        <motion.div onHoverStart={() => isHovered.set(1)} onHoverEnd={() => isHovered.set(0)} className="relative">
            <NavLink ref={ref} to={path} className="aspect-square w-14 bg-zinc-900/80 rounded-full flex items-center justify-center border-2 border-white/10"
                // FIX: Acknowledge the intentional use of `any` to satisfy the linter.
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                style={{ width: widthSync as any }}>
                {Children.map(children, child => React.isValidElement(child) ? cloneElement(child as React.ReactElement<{ isHovered?: MotionValue<number> }>, { isHovered }) : child)}
            </NavLink>
        </motion.div>
    );
}

function DockLabel({ children, isHovered }: { children: React.ReactNode, isHovered?: MotionValue<number> }) {
    const [isVisible, setIsVisible] = useState(false);
    useEffect(() => {
        if (!isHovered) return;
        const unsubscribe = isHovered.on('change', latest => setIsVisible(latest === 1));
        return () => unsubscribe();
    }, [isHovered]);

    return (
        <AnimatePresence>
            {isVisible && (
                <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: 10 }}
                    className="absolute -top-10 left-1/2 -translate-x-1/2 whitespace-nowrap rounded-md bg-zinc-900 px-2 py-1 text-xs text-white border border-white/10"
                >
                    {children}
                </motion.div>
            )}
        </AnimatePresence>
    );
}

function DockIcon({ children }: { children: React.ReactNode }) {
    return <div className="flex items-center justify-center text-white">{children}</div>;
}

export default function Dock({ items, className = '' }: DockProps) {
    const mouseX = useMotionValue(Infinity);
    return (
        <div onMouseMove={e => mouseX.set(e.pageX)} onMouseLeave={() => mouseX.set(Infinity)}
            className={`${className} flex h-16 items-end gap-4 rounded-2xl bg-black/30 px-4 pb-3 border border-white/10 backdrop-blur-lg`}
        >
            {items.map((item) => (
                <DockItem key={item.id} path={item.path} mouseX={mouseX}>
                    <DockIcon>{item.icon}</DockIcon>
                    <DockLabel>{item.label}</DockLabel>
                </DockItem>
            ))}
        </div>
    );
}
--- END OF FILE src/components/bits/Dock.tsx ---

--- START OF FILE src/components/bits/FuzzyText.tsx ---
// src/components/bits/FuzzyText.tsx
import React, { useEffect, useRef } from 'react';

interface FuzzyTextProps {
    children: React.ReactNode;
    fontSize?: number | string;
    fontWeight?: string | number;
    fontFamily?: string;
    color?: string;
    enableHover?: boolean;
    baseIntensity?: number;
    hoverIntensity?: number;
}

const FuzzyText: React.FC<FuzzyTextProps> = ({
    children,
    fontSize = 'clamp(2rem, 8vw, 8rem)',
    fontWeight = 900,
    fontFamily = 'inherit',
    color = '#fff',
    enableHover = true,
    baseIntensity = 0.18,
    hoverIntensity = 0.5
}) => {
    const canvasRef = useRef<HTMLCanvasElement & { cleanupFuzzyText?: () => void }>(null);

    useEffect(() => {
        let animationFrameId: number;
        let isCancelled = false;
        const canvas = canvasRef.current;
        if (!canvas) return;

        const init = async () => {
            if (document.fonts?.ready) {
                await document.fonts.ready;
            }
            if (isCancelled) return;

            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            const computedFontFamily =
                fontFamily === 'inherit' ? window.getComputedStyle(canvas).fontFamily || 'sans-serif' : fontFamily;

            const fontSizeStr = typeof fontSize === 'number' ? `${fontSize}px` : fontSize;
            let numericFontSize: number;
            if (typeof fontSize === 'number') {
                numericFontSize = fontSize;
            } else {
                const temp = document.createElement('span');
                temp.style.fontSize = fontSize;
                document.body.appendChild(temp);
                const computedSize = window.getComputedStyle(temp).fontSize;
                numericFontSize = parseFloat(computedSize);
                document.body.removeChild(temp);
            }

            const text = React.Children.toArray(children).join('');

            const offscreen = document.createElement('canvas');
            const offCtx = offscreen.getContext('2d');
            if (!offCtx) return;

            offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;
            offCtx.textBaseline = 'alphabetic';
            const metrics = offCtx.measureText(text);

            const actualLeft = metrics.actualBoundingBoxLeft ?? 0;
            const actualRight = metrics.actualBoundingBoxRight ?? metrics.width;
            const actualAscent = metrics.actualBoundingBoxAscent ?? numericFontSize;
            const actualDescent = metrics.actualBoundingBoxDescent ?? numericFontSize * 0.2;

            const textBoundingWidth = Math.ceil(actualLeft + actualRight);
            const tightHeight = Math.ceil(actualAscent + actualDescent);

            const extraWidthBuffer = 10;
            const offscreenWidth = textBoundingWidth + extraWidthBuffer;

            offscreen.width = offscreenWidth;
            offscreen.height = tightHeight;

            const xOffset = extraWidthBuffer / 2;
            offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;
            offCtx.textBaseline = 'alphabetic';
            offCtx.fillStyle = color;
            offCtx.fillText(text, xOffset - actualLeft, actualAscent);

            const horizontalMargin = 50;
            const verticalMargin = 0;
            canvas.width = offscreenWidth + horizontalMargin * 2;
            canvas.height = tightHeight + verticalMargin * 2;
            ctx.translate(horizontalMargin, verticalMargin);

            const interactiveLeft = horizontalMargin + xOffset;
            const interactiveTop = verticalMargin;
            const interactiveRight = interactiveLeft + textBoundingWidth;
            const interactiveBottom = interactiveTop + tightHeight;

            let isHovering = false;
            const fuzzRange = 30;

            const run = () => {
                if (isCancelled) return;
                ctx.clearRect(-fuzzRange, -fuzzRange, offscreenWidth + 2 * fuzzRange, tightHeight + 2 * fuzzRange);
                const intensity = isHovering ? hoverIntensity : baseIntensity;
                for (let j = 0; j < tightHeight; j++) {
                    const dx = Math.floor(intensity * (Math.random() - 0.5) * fuzzRange);
                    ctx.drawImage(offscreen, 0, j, offscreenWidth, 1, dx, j, offscreenWidth, 1);
                }
                animationFrameId = window.requestAnimationFrame(run);
            };

            run();

            const isInsideTextArea = (x: number, y: number) =>
                x >= interactiveLeft && x <= interactiveRight && y >= interactiveTop && y <= interactiveBottom;

            const handleMouseMove = (e: MouseEvent) => {
                if (!enableHover) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                isHovering = isInsideTextArea(x, y);
            };

            const handleMouseLeave = () => {
                isHovering = false;
            };

            const handleTouchMove = (e: TouchEvent) => {
                if (!enableHover) return;
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                isHovering = isInsideTextArea(x, y);
            };

            const handleTouchEnd = () => {
                isHovering = false;
            };

            if (enableHover) {
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseleave', handleMouseLeave);
                canvas.addEventListener('touchmove', handleTouchMove, {
                    passive: false
                });
                canvas.addEventListener('touchend', handleTouchEnd);
            }

            const cleanup = () => {
                window.cancelAnimationFrame(animationFrameId);
                if (enableHover) {
                    canvas.removeEventListener('mousemove', handleMouseMove);
                    canvas.removeEventListener('mouseleave', handleMouseLeave);
                    canvas.removeEventListener('touchmove', handleTouchMove);
                    canvas.removeEventListener('touchend', handleTouchEnd);
                }
            };

            canvas.cleanupFuzzyText = cleanup;
        };

        init();

        return () => {
            isCancelled = true;
            window.cancelAnimationFrame(animationFrameId);
            if (canvas && canvas.cleanupFuzzyText) {
                canvas.cleanupFuzzyText();
            }
        };
    }, [children, fontSize, fontWeight, fontFamily, color, enableHover, baseIntensity, hoverIntensity]);

    return <canvas ref={canvasRef} />;
};

export default FuzzyText;
--- END OF FILE src/components/bits/FuzzyText.tsx ---

--- START OF FILE src/components/bits/PixelBlast.tsx ---
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { EffectComposer, EffectPass, RenderPass, Effect } from 'postprocessing';

type PixelBlastVariant = 'square' | 'circle' | 'triangle' | 'diamond';

type PixelBlastProps = {
    variant?: PixelBlastVariant;
    pixelSize?: number;
    color?: string;
    className?: string;
    style?: React.CSSProperties;
    antialias?: boolean;
    patternScale?: number;
    patternDensity?: number;
    liquid?: boolean;
    liquidStrength?: number;
    liquidRadius?: number;
    pixelSizeJitter?: number;
    enableRipples?: boolean;
    rippleIntensityScale?: number;
    rippleThickness?: number;
    rippleSpeed?: number;
    liquidWobbleSpeed?: number;
    autoPauseOffscreen?: boolean;
    speed?: number;
    transparent?: boolean;
    edgeFade?: number;
    noiseAmount?: number;
};

const createTouchTexture = () => {
    const size = 64;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('2D context not available');
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const texture = new THREE.Texture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;
    const trail: {
        x: number;
        y: number;
        vx: number;
        vy: number;
        force: number;
        age: number;
    }[] = [];
    let last: { x: number; y: number } | null = null;
    const maxAge = 64;
    let radius = 0.1 * size;
    const speed = 1 / maxAge;
    const clear = () => {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    };
    const drawPoint = (p: { x: number; y: number; vx: number; vy: number; force: number; age: number }) => {
        const pos = { x: p.x * size, y: (1 - p.y) * size };
        let intensity = 1;
        const easeOutSine = (t: number) => Math.sin((t * Math.PI) / 2);
        const easeOutQuad = (t: number) => -t * (t - 2);
        if (p.age < maxAge * 0.3) intensity = easeOutSine(p.age / (maxAge * 0.3));
        else intensity = easeOutQuad(1 - (p.age - maxAge * 0.3) / (maxAge * 0.7)) || 0;
        intensity *= p.force;
        const color = `${((p.vx + 1) / 2) * 255}, ${((p.vy + 1) / 2) * 255}, ${intensity * 255}`;
        const offset = size * 5;
        ctx.shadowOffsetX = offset;
        ctx.shadowOffsetY = offset;
        ctx.shadowBlur = radius;
        ctx.shadowColor = `rgba(${color},${0.22 * intensity})`;
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,0,0,1)';
        ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);
        ctx.fill();
    };
    const addTouch = (norm: { x: number; y: number }) => {
        let force = 0;
        let vx = 0;
        let vy = 0;
        if (last) {
            const dx = norm.x - last.x;
            const dy = norm.y - last.y;
            if (dx === 0 && dy === 0) return;
            const dd = dx * dx + dy * dy;
            const d = Math.sqrt(dd);
            vx = dx / (d || 1);
            vy = dy / (d || 1);
            force = Math.min(dd * 10000, 1);
        }
        last = { x: norm.x, y: norm.y };
        trail.push({ x: norm.x, y: norm.y, age: 0, force, vx, vy });
    };
    const update = () => {
        clear();
        for (let i = trail.length - 1; i >= 0; i--) {
            const point = trail[i];
            const f = point.force * speed * (1 - point.age / maxAge);
            point.x += point.vx * f;
            point.y += point.vy * f;
            point.age++;
            if (point.age > maxAge) trail.splice(i, 1);
        }
        for (let i = 0; i < trail.length; i++) drawPoint(trail[i]);
        texture.needsUpdate = true;
    };
    return {
        canvas,
        texture,
        addTouch,
        update,
        set radiusScale(v: number) {
            radius = 0.1 * size * v;
        },
        get radiusScale() {
            return radius / (0.1 * size);
        },
        size
    };
};

const createLiquidEffect = (texture: THREE.Texture, opts?: { strength?: number; freq?: number }) => {
    const fragment = `
    uniform sampler2D uTexture;
    uniform float uStrength;
    uniform float uTime;
    uniform float uFreq;

    void mainUv(inout vec2 uv) {
      vec4 tex = texture2D(uTexture, uv);
      float vx = tex.r * 2.0 - 1.0;
      float vy = tex.g * 2.0 - 1.0;
      float intensity = tex.b;

      float wave = 0.5 + 0.5 * sin(uTime * uFreq + intensity * 6.2831853);

      float amt = uStrength * intensity * wave;

      uv += vec2(vx, vy) * amt;
    }
    `;
    return new Effect('LiquidEffect', fragment, {
        uniforms: new Map<string, THREE.Uniform>([
            ['uTexture', new THREE.Uniform(texture)],
            ['uStrength', new THREE.Uniform(opts?.strength ?? 0.025)],
            ['uTime', new THREE.Uniform(0)],
            ['uFreq', new THREE.Uniform(opts?.freq ?? 4.5)]
        ])
    });
};

const SHAPE_MAP: Record<PixelBlastVariant, number> = {
    square: 0,
    circle: 1,
    triangle: 2,
    diamond: 3
};

const VERTEX_SRC = `
void main() {
  gl_Position = vec4(position, 1.0);
}
`;

const FRAGMENT_SRC = `
precision highp float;

uniform vec3  uColor;
uniform vec2  uResolution;
uniform float uTime;
uniform float uPixelSize;
uniform float uScale;
uniform float uDensity;
uniform float uPixelJitter;
uniform int   uEnableRipples;
uniform float uRippleSpeed;
uniform float uRippleThickness;
uniform float uRippleIntensity;
uniform float uEdgeFade;

uniform int   uShapeType;
const int SHAPE_SQUARE   = 0;
const int SHAPE_CIRCLE   = 1;
const int SHAPE_TRIANGLE = 2;
const int SHAPE_DIAMOND  = 3;

const int   MAX_CLICKS = 10;

uniform vec2  uClickPos  [MAX_CLICKS];
uniform float uClickTimes[MAX_CLICKS];

out vec4 fragColor;

float Bayer2(vec2 a) {
  a = floor(a);
  return fract(a.x / 2. + a.y * a.y * .75);
}
#define Bayer4(a) (Bayer2(.5*(a))*0.25 + Bayer2(a))
#define Bayer8(a) (Bayer4(.5*(a))*0.25 + Bayer2(a))

#define FBM_OCTAVES     5
#define FBM_LACUNARITY  1.25
#define FBM_GAIN        1.0

float hash11(float n){ return fract(sin(n)*43758.5453); }

float vnoise(vec3 p){
  vec3 ip = floor(p);
  vec3 fp = fract(p);
  float n000 = hash11(dot(ip + vec3(0.0,0.0,0.0), vec3(1.0,57.0,113.0)));
  float n100 = hash11(dot(ip + vec3(1.0,0.0,0.0), vec3(1.0,57.0,113.0)));
  float n010 = hash11(dot(ip + vec3(0.0,1.0,0.0), vec3(1.0,57.0,113.0)));
  float n110 = hash11(dot(ip + vec3(1.0,1.0,0.0), vec3(1.0,57.0,113.0)));
  float n001 = hash11(dot(ip + vec3(0.0,0.0,1.0), vec3(1.0,57.0,113.0)));
  float n101 = hash11(dot(ip + vec3(1.0,0.0,1.0), vec3(1.0,57.0,113.0)));
  float n011 = hash11(dot(ip + vec3(0.0,1.0,1.0), vec3(1.0,57.0,113.0)));
  float n111 = hash11(dot(ip + vec3(1.0,1.0,1.0), vec3(1.0,57.0,113.0)));
  vec3 w = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);
  float x00 = mix(n000, n100, w.x);
  float x10 = mix(n010, n110, w.x);
  float x01 = mix(n001, n101, w.x);
  float x11 = mix(n011, n111, w.x);
  float y0  = mix(x00, x10, w.y);
  float y1  = mix(x01, x11, w.y);
  return mix(y0, y1, w.z) * 2.0 - 1.0;
}

float fbm2(vec2 uv, float t){
  vec3 p = vec3(uv * uScale, t);
  float amp = 1.0;
  float freq = 1.0;
  float sum = 1.0;
  for (int i = 0; i < FBM_OCTAVES; ++i){
    sum  += amp * vnoise(p * freq);
    freq *= FBM_LACUNARITY;
    amp  *= FBM_GAIN;
  }
  return sum * 0.5 + 0.5;
}

float maskCircle(vec2 p, float cov){
  float r = sqrt(cov) * .25;
  float d = length(p - 0.5) - r;
  float aa = 0.5 * fwidth(d);
  return cov * (1.0 - smoothstep(-aa, aa, d * 2.0));
}

float maskTriangle(vec2 p, vec2 id, float cov){
  bool flip = mod(id.x + id.y, 2.0) > 0.5;
  if (flip) p.x = 1.0 - p.x;
  float r = sqrt(cov);
  float d  = p.y - r*(1.0 - p.x);
  float aa = fwidth(d);
  return cov * clamp(0.5 - d/aa, 0.0, 1.0);
}

float maskDiamond(vec2 p, float cov){
  float r = sqrt(cov) * 0.564;
  return step(abs(p.x - 0.49) + abs(p.y - 0.49), r);
}

void main(){
  float pixelSize = uPixelSize;
  vec2 fragCoord = gl_FragCoord.xy - uResolution * .5;
  float aspectRatio = uResolution.x / uResolution.y;

  vec2 pixelId = floor(fragCoord / pixelSize);
  vec2 pixelUV = fract(fragCoord / pixelSize);

  float cellPixelSize = 8.0 * pixelSize;
  vec2 cellId = floor(fragCoord / cellPixelSize);
  vec2 cellCoord = cellId * cellPixelSize;
  vec2 uv = cellCoord / uResolution * vec2(aspectRatio, 1.0);

  float base = fbm2(uv, uTime * 0.05);
  base = base * 0.5 - 0.65;

  float feed = base + (uDensity - 0.5) * 0.3;

  float speed     = uRippleSpeed;
  float thickness = uRippleThickness;
  const float dampT     = 1.0;
  const float dampR     = 10.0;

  if (uEnableRipples == 1) {
    for (int i = 0; i < MAX_CLICKS; ++i){
      vec2 pos = uClickPos[i];
      if (pos.x < 0.0) continue;
      float cellPixelSize = 8.0 * pixelSize;
      vec2 cuv = (((pos - uResolution * .5 - cellPixelSize * .5) / (uResolution))) * vec2(aspectRatio, 1.0);
      float t = max(uTime - uClickTimes[i], 0.0);
      float r = distance(uv, cuv);
      float waveR = speed * t;
      float ring  = exp(-pow((r - waveR) / thickness, 2.0));
      float atten = exp(-dampT * t) * exp(-dampR * r);
      feed = max(feed, ring * atten * uRippleIntensity);
    }
  }

  float bayer = Bayer8(fragCoord / uPixelSize) - 0.5;
  float bw = step(0.5, feed + bayer);

  float h = fract(sin(dot(floor(fragCoord / uPixelSize), vec2(127.1, 311.7))) * 43758.5453);
  float jitterScale = 1.0 + (h - 0.5) * uPixelJitter;
  float coverage = bw * jitterScale;
  float M;
  if      (uShapeType == SHAPE_CIRCLE)   M = maskCircle (pixelUV, coverage);
  else if (uShapeType == SHAPE_TRIANGLE) M = maskTriangle(pixelUV, pixelId, coverage);
  else if (uShapeType == SHAPE_DIAMOND)  M = maskDiamond(pixelUV, coverage);
  else                                   M = coverage;

  if (uEdgeFade > 0.0) {
    vec2 norm = gl_FragCoord.xy / uResolution;
    float edge = min(min(norm.x, norm.y), min(1.0 - norm.x, 1.0 - norm.y));
    float fade = smoothstep(0.0, uEdgeFade, edge);
    M *= fade;
  }

  vec3 color = uColor;
  fragColor = vec4(color, M);
}
`;

const MAX_CLICKS = 10;

type PixelBlastConfig = {
    antialias: boolean;
    liquid: boolean;
    noiseAmount: number;
};

const PixelBlast: React.FC<PixelBlastProps> = ({
    variant = 'square',
    pixelSize = 3,
    color = '#B19EEF',
    className,
    style,
    antialias = true,
    patternScale = 2,
    patternDensity = 1,
    liquid = false,
    liquidStrength = 0.1,
    liquidRadius = 1,
    pixelSizeJitter = 0,
    enableRipples = true,
    rippleIntensityScale = 1,
    rippleThickness = 0.1,
    rippleSpeed = 0.3,
    liquidWobbleSpeed = 4.5,
    autoPauseOffscreen = true,
    speed = 0.5,
    transparent = true,
    edgeFade = 0.5,
    noiseAmount = 0
}) => {
    const containerRef = useRef<HTMLDivElement | null>(null);
    const visibilityRef = useRef({ visible: true });
    const speedRef = useRef(speed);

    const threeRef = useRef<{
        renderer: THREE.WebGLRenderer;
        scene: THREE.Scene;
        camera: THREE.OrthographicCamera;
        material: THREE.ShaderMaterial;
        clock: THREE.Clock;
        clickIx: number;
        uniforms: {
            uResolution: { value: THREE.Vector2 };
            uTime: { value: number };
            uColor: { value: THREE.Color };
            uClickPos: { value: THREE.Vector2[] };
            uClickTimes: { value: Float32Array };
            uShapeType: { value: number };
            uPixelSize: { value: number };
            uScale: { value: number };
            uDensity: { value: number };
            uPixelJitter: { value: number };
            uEnableRipples: { value: number };
            uRippleSpeed: { value: number };
            uRippleThickness: { value: number };
            uRippleIntensity: { value: number };
            uEdgeFade: { value: number };
        };
        resizeObserver?: ResizeObserver;
        raf?: number;
        quad?: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>;
        timeOffset?: number;
        composer?: EffectComposer;
        touch?: ReturnType<typeof createTouchTexture>;
        liquidEffect?: Effect;
    } | null>(null);
    const prevConfigRef = useRef<PixelBlastConfig | null>(null);
    useEffect(() => {
        const container = containerRef.current;
        if (!container) return;
        speedRef.current = speed;
        const needsReinitKeys: (keyof PixelBlastConfig)[] = ['antialias', 'liquid', 'noiseAmount'];
        const cfg: PixelBlastConfig = { antialias, liquid, noiseAmount };
        let mustReinit = false;
        if (!threeRef.current) mustReinit = true;
        else if (prevConfigRef.current) {
            for (const k of needsReinitKeys)
                if (prevConfigRef.current[k] !== cfg[k]) {
                    mustReinit = true;
                    break;
                }
        }
        if (mustReinit) {
            if (threeRef.current) {
                const t = threeRef.current;
                t.resizeObserver?.disconnect();
                cancelAnimationFrame(t.raf!);
                t.quad?.geometry.dispose();
                t.material.dispose();
                t.composer?.dispose();
                t.renderer.dispose();
                if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);
                threeRef.current = null;
            }
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl2', { antialias, alpha: true });
            if (!gl) return;
            const renderer = new THREE.WebGLRenderer({
                canvas,
                context: gl as WebGL2RenderingContext,
                antialias,
                alpha: true
            });
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            container.appendChild(renderer.domElement);
            const uniforms = {
                uResolution: { value: new THREE.Vector2(0, 0) },
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(color) },
                uClickPos: {
                    value: Array.from({ length: MAX_CLICKS }, () => new THREE.Vector2(-1, -1))
                },
                uClickTimes: { value: new Float32Array(MAX_CLICKS) },
                uShapeType: { value: SHAPE_MAP[variant] ?? 0 },
                uPixelSize: { value: pixelSize * renderer.getPixelRatio() },
                uScale: { value: patternScale },
                uDensity: { value: patternDensity },
                uPixelJitter: { value: pixelSizeJitter },
                uEnableRipples: { value: enableRipples ? 1 : 0 },
                uRippleSpeed: { value: rippleSpeed },
                uRippleThickness: { value: rippleThickness },
                uRippleIntensity: { value: rippleIntensityScale },
                uEdgeFade: { value: edgeFade }
            };
            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const material = new THREE.ShaderMaterial({
                vertexShader: VERTEX_SRC,
                fragmentShader: FRAGMENT_SRC,
                uniforms,
                transparent: true,
                glslVersion: THREE.GLSL3,
                depthTest: false,
                depthWrite: false
            });
            const quadGeom = new THREE.PlaneGeometry(2, 2);
            const quad = new THREE.Mesh(quadGeom, material);
            scene.add(quad);
            const clock = new THREE.Clock();
            const setSize = () => {
                const w = container.clientWidth || 1;
                const h = container.clientHeight || 1;
                renderer.setSize(w, h, false);
                uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);
                if (threeRef.current?.composer)
                    threeRef.current.composer.setSize(renderer.domElement.width, renderer.domElement.height);
                uniforms.uPixelSize.value = pixelSize * renderer.getPixelRatio();
            };
            setSize();
            const ro = new ResizeObserver(setSize);
            ro.observe(container);
            const randomFloat = () => {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (typeof window !== 'undefined' && (window as any).crypto?.getRandomValues) {
                    const u32 = new Uint32Array(1);
                    window.crypto.getRandomValues(u32);
                    return u32[0] / 0xffffffff;
                }
                return Math.random();
            };
            const timeOffset = randomFloat() * 1000;
            let composer: EffectComposer | undefined;
            let touch: ReturnType<typeof createTouchTexture> | undefined;
            let liquidEffect: Effect | undefined;
            if (liquid) {
                touch = createTouchTexture();
                touch.radiusScale = liquidRadius;
                composer = new EffectComposer(renderer);
                const renderPass = new RenderPass(scene, camera);
                liquidEffect = createLiquidEffect(touch.texture, {
                    strength: liquidStrength,
                    freq: liquidWobbleSpeed
                });
                const effectPass = new EffectPass(camera, liquidEffect);
                effectPass.renderToScreen = true;
                composer.addPass(renderPass);
                composer.addPass(effectPass);
            }
            if (noiseAmount > 0) {
                if (!composer) {
                    composer = new EffectComposer(renderer);
                    composer.addPass(new RenderPass(scene, camera));
                }
                const noiseEffect = new Effect(
                    'NoiseEffect',
                    `uniform float uTime; uniform float uAmount; float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);} void mainUv(inout vec2 uv){} void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){ float n=hash(floor(uv*vec2(1920.0,1080.0))+floor(uTime*60.0)); float g=(n-0.5)*uAmount; outputColor=inputColor+vec4(vec3(g),0.0);} `,
                    {
                        uniforms: new Map<string, THREE.Uniform>([
                            ['uTime', new THREE.Uniform(0)],
                            ['uAmount', new THREE.Uniform(noiseAmount)]
                        ])
                    }
                );
                const noisePass = new EffectPass(camera, noiseEffect);
                noisePass.renderToScreen = true;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (composer && composer.passes.length > 0) composer.passes.forEach(p => ((p as any).renderToScreen = false));
                composer.addPass(noisePass);
            }
            if (composer) composer.setSize(renderer.domElement.width, renderer.domElement.height);
            const mapToPixels = (e: PointerEvent) => {
                const rect = renderer.domElement.getBoundingClientRect();
                const scaleX = renderer.domElement.width / rect.width;
                const scaleY = renderer.domElement.height / rect.height;
                const fx = (e.clientX - rect.left) * scaleX;
                const fy = (rect.height - (e.clientY - rect.top)) * scaleY;
                return {
                    fx,
                    fy,
                    w: renderer.domElement.width,
                    h: renderer.domElement.height
                };
            };
            const onPointerDown = (e: PointerEvent) => {
                const { fx, fy } = mapToPixels(e);
                const ix = threeRef.current?.clickIx ?? 0;
                uniforms.uClickPos.value[ix].set(fx, fy);
                uniforms.uClickTimes.value[ix] = uniforms.uTime.value;
                if (threeRef.current) threeRef.current.clickIx = (ix + 1) % MAX_CLICKS;
            };
            const onPointerMove = (e: PointerEvent) => {
                if (!touch) return;
                const { fx, fy, w, h } = mapToPixels(e);
                touch.addTouch({ x: fx / w, y: fy / h });
            };
            renderer.domElement.addEventListener('pointerdown', onPointerDown, {
                passive: true
            });
            renderer.domElement.addEventListener('pointermove', onPointerMove, {
                passive: true
            });
            let raf = 0;
            const animate = () => {
                if (autoPauseOffscreen && !visibilityRef.current.visible) {
                    raf = requestAnimationFrame(animate);
                    return;
                }
                uniforms.uTime.value = timeOffset + clock.getElapsedTime() * speedRef.current;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (liquidEffect) (liquidEffect as any).uniforms.get('uTime').value = uniforms.uTime.value;
                if (composer) {
                    if (touch) touch.update();
                    composer.passes.forEach(p => {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        const effs = (p as any).effects;
                        if (effs)
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            effs.forEach((eff: any) => {
                                const u = eff.uniforms?.get('uTime');
                                if (u) u.value = uniforms.uTime.value;
                            });
                    });
                    composer.render();
                } else renderer.render(scene, camera);
                raf = requestAnimationFrame(animate);
            };
            raf = requestAnimationFrame(animate);
            threeRef.current = {
                renderer,
                scene,
                camera,
                material,
                clock,
                clickIx: 0,
                uniforms,
                resizeObserver: ro,
                raf,
                quad,
                timeOffset,
                composer,
                touch,
                liquidEffect
            };
        } else {
            const t = threeRef.current!;
            t.uniforms.uShapeType.value = SHAPE_MAP[variant] ?? 0;
            t.uniforms.uPixelSize.value = pixelSize * t.renderer.getPixelRatio();
            t.uniforms.uColor.value.set(color);
            t.uniforms.uScale.value = patternScale;
            t.uniforms.uDensity.value = patternDensity;
            t.uniforms.uPixelJitter.value = pixelSizeJitter;
            t.uniforms.uEnableRipples.value = enableRipples ? 1 : 0;
            t.uniforms.uRippleIntensity.value = rippleIntensityScale;
            t.uniforms.uRippleThickness.value = rippleThickness;
            t.uniforms.uRippleSpeed.value = rippleSpeed;
            t.uniforms.uEdgeFade.value = edgeFade;
            if (transparent) t.renderer.setClearAlpha(0);
            else t.renderer.setClearColor(0x000000, 1);
            if (t.liquidEffect) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const uStrength = (t.liquidEffect as any).uniforms.get('uStrength');
                if (uStrength) uStrength.value = liquidStrength;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const uFreq = (t.liquidEffect as any).uniforms.get('uFreq');
                if (uFreq) uFreq.value = liquidWobbleSpeed;
            }
            if (t.touch) t.touch.radiusScale = liquidRadius;
        }
        prevConfigRef.current = cfg;
        return () => {
            if (threeRef.current && mustReinit) return;
            if (!threeRef.current) return;
            const t = threeRef.current;
            t.resizeObserver?.disconnect();
            cancelAnimationFrame(t.raf!);
            t.quad?.geometry.dispose();
            t.material.dispose();
            t.composer?.dispose();
            t.renderer.dispose();
            if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);
            threeRef.current = null;
        };
    }, [
        antialias,
        liquid,
        noiseAmount,
        pixelSize,
        patternScale,
        patternDensity,
        enableRipples,
        rippleIntensityScale,
        rippleThickness,
        rippleSpeed,
        pixelSizeJitter,
        edgeFade,
        transparent,
        liquidStrength,
        liquidRadius,
        liquidWobbleSpeed,
        autoPauseOffscreen,
        variant,
        color,
        speed
    ]);

    return (
        <div
            ref={containerRef}
            className={`w-full h-full relative overflow-hidden ${className ?? ''}`}
            style={style}
            aria-label="PixelBlast interactive background"
        />
    );
};

export default PixelBlast;
--- END OF FILE src/components/bits/PixelBlast.tsx ---

--- START OF FILE src/components/bits/ShinyText.tsx ---
import React from 'react';
import { cn } from '@/lib/utils';

interface ShinyTextProps {
    text: string;
    disabled?: boolean;
    speed?: number;
    className?: string;
}

const ShinyText: React.FC<ShinyTextProps> = ({ text, disabled = false, speed = 5, className = '' }) => {
    const animationDuration = `${speed}s`;

    return (
        <div
            className={cn(
                'bg-clip-text text-transparent',
                !disabled && 'animate-shine',
                className
            )}
            style={{
                backgroundImage:
                    'linear-gradient(120deg, white 10%, var(--color-muted-foreground) 50%, white 70%)',
                backgroundSize: '200% 100%',
                WebkitBackgroundClip: 'text',
                animationDuration,
            }}
        >
            {text}
        </div>
    );
};

export default ShinyText;
--- END OF FILE src/components/bits/ShinyText.tsx ---

--- START OF FILE src/components/bits/Silk.tsx ---
import React, { forwardRef, useMemo, useRef, useLayoutEffect } from 'react';
import { Canvas, useFrame, useThree, RootState } from '@react-three/fiber';
import { Color, Mesh, ShaderMaterial } from 'three';
import { IUniform } from 'three';

type NormalizedRGB = [number, number, number];

const hexToNormalizedRGB = (hex: string): NormalizedRGB => {
  const clean = hex.replace('#', '');
  const r = parseInt(clean.slice(0, 2), 16) / 255;
  const g = parseInt(clean.slice(2, 4), 16) / 255;
  const b = parseInt(clean.slice(4, 6), 16) / 255;
  return [r, g, b];
};

interface UniformValue<T = number | Color> {
  value: T;
}

interface SilkUniforms {
  uSpeed: UniformValue<number>;
  uScale: UniformValue<number>;
  uNoiseIntensity: UniformValue<number>;
  uColor: UniformValue<Color>;
  uRotation: UniformValue<number>;
  uTime: UniformValue<number>;
  [uniform: string]: IUniform;
}

const vertexShader = `
varying vec2 vUv;
varying vec3 vPosition;

void main() {
  vPosition = position;
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

const fragmentShader = `
varying vec2 vUv;
varying vec3 vPosition;

uniform float uTime;
uniform vec3  uColor;
uniform float uSpeed;
uniform float uScale;
uniform float uRotation;
uniform float uNoiseIntensity;

const float e = 2.71828182845904523536;

float noise(vec2 texCoord) {
  float G = e;
  vec2  r = (G * sin(G * texCoord));
  return fract(r.x * r.y * (1.0 + texCoord.x));
}

vec2 rotateUvs(vec2 uv, float angle) {
  float c = cos(angle);
  float s = sin(angle);
  mat2  rot = mat2(c, -s, s, c);
  return rot * uv;
}

void main() {
  float rnd        = noise(gl_FragCoord.xy);
  vec2  uv         = rotateUvs(vUv * uScale, uRotation);
  vec2  tex        = uv * uScale;
  float tOffset    = uSpeed * uTime;

  tex.y += 0.03 * sin(8.0 * tex.x - tOffset);

  float pattern = 0.6 +
                  0.4 * sin(5.0 * (tex.x + tex.y +
                                   cos(3.0 * tex.x + 5.0 * tex.y) +
                                   0.02 * tOffset) +
                           sin(20.0 * (tex.x + tex.y - 0.1 * tOffset)));

  vec4 col = vec4(uColor, 1.0) * vec4(pattern) - rnd / 15.0 * uNoiseIntensity;
  col.a = 1.0;
  gl_FragColor = col;
}
`;

interface SilkPlaneProps {
  uniforms: SilkUniforms;
}

const SilkPlane = forwardRef<Mesh, SilkPlaneProps>(function SilkPlane({ uniforms }, ref) {
  const { viewport } = useThree();

  useLayoutEffect(() => {
    const mesh = ref as React.MutableRefObject<Mesh | null>;
    if (mesh.current) {
      mesh.current.scale.set(viewport.width, viewport.height, 1);
    }
  }, [ref, viewport]);

  useFrame((_state: RootState, delta: number) => {
    const mesh = ref as React.MutableRefObject<Mesh | null>;
    if (mesh.current) {
      const material = mesh.current.material as ShaderMaterial & {
        uniforms: SilkUniforms;
      };
      material.uniforms.uTime.value += 0.1 * delta;
    }
  });

  return (
    <mesh ref={ref}>
      <planeGeometry args={[1, 1, 1, 1]} />
      <shaderMaterial uniforms={uniforms} vertexShader={vertexShader} fragmentShader={fragmentShader} />
    </mesh>
  );
});
SilkPlane.displayName = 'SilkPlane';

export interface SilkProps {
  speed?: number;
  scale?: number;
  color?: string;
  noiseIntensity?: number;
  rotation?: number;
}

const Silk: React.FC<SilkProps> = ({ speed = 5, scale = 1, color = '#7B7481', noiseIntensity = 1.5, rotation = 0 }) => {
  const meshRef = useRef<Mesh>(null);

  const uniforms = useMemo<SilkUniforms>(
    () => ({
      uSpeed: { value: speed },
      uScale: { value: scale },
      uNoiseIntensity: { value: noiseIntensity },
      uColor: { value: new Color(...hexToNormalizedRGB(color)) },
      uRotation: { value: rotation },
      uTime: { value: 0 }
    }),
    [speed, scale, noiseIntensity, color, rotation]
  );

  return (
    <Canvas dpr={[1, 2]} frameloop="always">
      <SilkPlane ref={meshRef} uniforms={uniforms} />
    </Canvas>
  );
};

export default Silk;
--- END OF FILE src/components/bits/Silk.tsx ---

--- START OF FILE src/components/bits/StaggeredMenu.tsx ---
import React, { useCallback, useLayoutEffect, useRef, useState, useEffect } from 'react';
import { NavLink } from 'react-router-dom';
import { gsap } from 'gsap';
import TargetCursor from './TargetCursor';

export interface StaggeredMenuItem {
    label: string;
    ariaLabel: string;
    link: string;
}
export interface StaggeredMenuSocialItem {
    label: string;
    link: string;
}
export interface StaggeredMenuProps {
    position?: 'left' | 'right';
    colors?: string[];
    items?: StaggeredMenuItem[];
    socialItems?: StaggeredMenuSocialItem[];
    displaySocials?: boolean;
    displayItemNumbering?: boolean;
    className?: string;
    logo?: React.ReactNode;
    menuButtonColor?: string;
    openMenuButtonColor?: string;
    accentColor?: string;
    isFixed?: boolean;
    changeMenuColorOnOpen?: boolean;
    onMenuOpen?: () => void;
    onMenuClose?: () => void;
    isOpen: boolean;
    onToggle: () => void;
    onClose: () => void;
    initialCursorPos?: { x: number; y: number };
}

export const StaggeredMenu: React.FC<StaggeredMenuProps> = ({
    position = 'right',
    colors = ['#1e1e22', '#35353c'],
    items = [],
    socialItems = [],
    displaySocials = true,
    displayItemNumbering = true,
    className,
    logo,
    menuButtonColor = '#fff',
    openMenuButtonColor = '#fff',
    changeMenuColorOnOpen = true,
    accentColor = '#FAFAFA',
    isFixed = false,
    onMenuOpen,
    onMenuClose,
    isOpen,
    onToggle,
    onClose,
    initialCursorPos
}: StaggeredMenuProps) => {
    const panelRef = useRef<HTMLDivElement | null>(null);
    const headerRef = useRef<HTMLElement | null>(null);
    const preLayersRef = useRef<HTMLDivElement | null>(null);
    const preLayerElsRef = useRef<HTMLElement[]>([]);
    const plusHRef = useRef<HTMLSpanElement | null>(null);
    const plusVRef = useRef<HTMLSpanElement | null>(null);
    const iconRef = useRef<HTMLSpanElement | null>(null);
    const textInnerRef = useRef<HTMLSpanElement | null>(null);
    const [textLines, setTextLines] = useState<string[]>(['Menu', 'Close']);
    const openTlRef = useRef<gsap.core.Timeline | null>(null);
    const closeTweenRef = useRef<gsap.core.Tween | null>(null);
    const spinTweenRef = useRef<gsap.core.Timeline | null>(null);
    const textCycleAnimRef = useRef<gsap.core.Tween | null>(null);
    const colorTweenRef = useRef<gsap.core.Tween | null>(null);
    const toggleBtnRef = useRef<HTMLButtonElement | null>(null);
    const busyRef = useRef(false);
    const itemEntranceTweenRef = useRef<gsap.core.Tween | null>(null);
    const isMounted = useRef(false);
    const [isDesktop, setIsDesktop] = useState(false);

    useEffect(() => {
        const mediaQuery = window.matchMedia('(min-width: 1024px)'); // lg breakpoint
        const handleMediaQueryChange = (e: MediaQueryListEvent) => {
            setIsDesktop(e.matches);
        };
        setIsDesktop(mediaQuery.matches);
        mediaQuery.addEventListener('change', handleMediaQueryChange);
        return () => {
            mediaQuery.removeEventListener('change', handleMediaQueryChange);
        };
    }, []);

    useEffect(() => {
        if (!isOpen) return;

        const handleClickOutside = (event: MouseEvent) => {
            if (
                panelRef.current && !panelRef.current.contains(event.target as Node) &&
                toggleBtnRef.current && !toggleBtnRef.current.contains(event.target as Node)
            ) {
                onClose();
            }
        };

        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [isOpen, onClose]);

    useEffect(() => {
        if (headerRef.current) {
            gsap.fromTo(headerRef.current, { opacity: 0 }, { opacity: 1, duration: 0.5, delay: 0.2 });
        }
    }, []);


    useLayoutEffect(() => {
        const ctx = gsap.context(() => {
            const panel = panelRef.current; const preContainer = preLayersRef.current;
            const plusH = plusHRef.current; const plusV = plusVRef.current;
            const icon = iconRef.current; const textInner = textInnerRef.current;
            if (!panel || !plusH || !plusV || !icon || !textInner) return;
            let preLayers: HTMLElement[] = [];
            if (preContainer) { preLayers = Array.from(preContainer.querySelectorAll('.sm-prelayer')) as HTMLElement[]; }
            preLayerElsRef.current = preLayers;
            const offscreen = position === 'left' ? -100 : 100;
            gsap.set([panel, ...preLayers], { xPercent: offscreen });
            gsap.set(plusH, { transformOrigin: '50% 50%', rotate: 0 });
            gsap.set(plusV, { transformOrigin: '50% 50%', rotate: 90 });
            gsap.set(icon, { rotate: 0, transformOrigin: '50% 50%' });
            gsap.set(textInner, { yPercent: 0 });
            if (toggleBtnRef.current) gsap.set(toggleBtnRef.current, { color: menuButtonColor });
        });
        return () => ctx.revert();
    }, [menuButtonColor, position]);

    const buildOpenTimeline = useCallback(() => {
        const panel = panelRef.current; const layers = preLayerElsRef.current; if (!panel) return null;
        openTlRef.current?.kill();
        if (closeTweenRef.current) { closeTweenRef.current.kill(); closeTweenRef.current = null; }
        itemEntranceTweenRef.current?.kill();
        const itemEls = Array.from(panel.querySelectorAll('.sm-panel-itemLabel')) as HTMLElement[];
        const numberEls = Array.from(panel.querySelectorAll('.sm-panel-list[data-numbering] .sm-panel-item')) as HTMLElement[];
        const socialTitle = panel.querySelector('.sm-socials-title') as HTMLElement | null;
        const socialLinks = Array.from(panel.querySelectorAll('.sm-socials-link')) as HTMLElement[];
        const layerStates = layers.map(el => ({ el, start: Number(gsap.getProperty(el, 'xPercent')) }));
        const panelStart = Number(gsap.getProperty(panel, 'xPercent'));
        if (itemEls.length) gsap.set(itemEls, { yPercent: 140, rotate: 10 });
        if (numberEls.length) gsap.set(numberEls, { ['--sm-num-opacity']: 0 });
        if (socialTitle) gsap.set(socialTitle, { opacity: 0 });
        if (socialLinks.length) gsap.set(socialLinks, { y: 25, opacity: 0 });
        const tl = gsap.timeline({ paused: true });
        layerStates.forEach((ls, i) => { tl.fromTo(ls.el, { xPercent: ls.start }, { xPercent: 0, duration: 0.5, ease: 'power4.out' }, i * 0.07); });
        const lastTime = layerStates.length ? (layerStates.length - 1) * 0.07 : 0;
        const panelInsertTime = lastTime + (layerStates.length ? 0.08 : 0);
        const panelDuration = 0.65;
        tl.fromTo(panel, { xPercent: panelStart }, { xPercent: 0, duration: panelDuration, ease: 'power4.out' }, panelInsertTime);
        if (itemEls.length) {
            const itemsStart = panelInsertTime + panelDuration * 0.15;
            tl.to(itemEls, { yPercent: 0, rotate: 0, duration: 1, ease: 'power4.out', stagger: { each: 0.1, from: 'start' } }, itemsStart);
            if (numberEls.length) {
                tl.to(numberEls, { duration: 0.6, ease: 'power2.out', ['--sm-num-opacity']: 1, stagger: { each: 0.08, from: 'start' } }, itemsStart + 0.1);
            }
        }
        if (socialTitle || socialLinks.length) {
            const socialsStart = panelInsertTime + panelDuration * 0.4;
            if (socialTitle) tl.to(socialTitle, { opacity: 1, duration: 0.5, ease: 'power2.out' }, socialsStart);
            if (socialLinks.length) {
                tl.to(socialLinks, { y: 0, opacity: 1, duration: 0.55, ease: 'power3.out', stagger: { each: 0.08, from: 'start' }, onComplete: () => { gsap.set(socialLinks, { clearProps: 'opacity' }); } }, socialsStart + 0.04);
            }
        }
        openTlRef.current = tl;
        return tl;
    }, []);

    const playOpen = useCallback(() => {
        if (busyRef.current) return; busyRef.current = true;
        const tl = buildOpenTimeline();
        if (tl) { tl.eventCallback('onComplete', () => { busyRef.current = false; }); tl.play(0); }
        else { busyRef.current = false; }
    }, [buildOpenTimeline]);

    const playClose = useCallback(() => {
        openTlRef.current?.kill(); openTlRef.current = null; itemEntranceTweenRef.current?.kill();
        const panel = panelRef.current; const layers = preLayerElsRef.current; if (!panel) return;
        const all: HTMLElement[] = [...layers, panel]; closeTweenRef.current?.kill();
        const offscreen = position === 'left' ? -100 : 100;
        closeTweenRef.current = gsap.to(all, {
            xPercent: offscreen, duration: 0.32, ease: 'power3.in', overwrite: 'auto', onComplete: () => {
                const itemEls = Array.from(panel.querySelectorAll('.sm-panel-itemLabel')) as HTMLElement[];
                if (itemEls.length) gsap.set(itemEls, { yPercent: 140, rotate: 10 });
                const numberEls = Array.from(panel.querySelectorAll('.sm-panel-list[data-numbering] .sm-panel-item')) as HTMLElement[];
                if (numberEls.length) gsap.set(numberEls, { ['--sm-num-opacity']: 0 });
                const socialTitle = panel.querySelector('.sm-socials-title') as HTMLElement | null;
                const socialLinks = Array.from(panel.querySelectorAll('.sm-socials-link')) as HTMLElement[];
                if (socialTitle) gsap.set(socialTitle, { opacity: 0 });
                if (socialLinks.length) gsap.set(socialLinks, { y: 25, opacity: 0 });
                busyRef.current = false;
            }
        });
    }, [position]);

    const animateIcon = useCallback((opening: boolean) => {
        const icon = iconRef.current; const h = plusHRef.current; const v = plusVRef.current; if (!icon || !h || !v) return;
        spinTweenRef.current?.kill();
        if (opening) {
            gsap.set(icon, { rotate: 0, transformOrigin: '50% 50%' });
            spinTweenRef.current = gsap.timeline({ defaults: { ease: 'power4.out' } }).to(h, { rotate: 45, duration: 0.5 }, 0).to(v, { rotate: -45, duration: 0.5 }, 0);
        } else {
            spinTweenRef.current = gsap.timeline({ defaults: { ease: 'power3.inOut' } }).to(h, { rotate: 0, duration: 0.35 }, 0).to(v, { rotate: 90, duration: 0.35 }, 0).to(icon, { rotate: 0, duration: 0.001 }, 0);
        }
    }, []);

    const animateColor = useCallback((opening: boolean) => {
        const btn = toggleBtnRef.current; if (!btn) return; colorTweenRef.current?.kill();
        if (changeMenuColorOnOpen) {
            const targetColor = opening ? openMenuButtonColor : menuButtonColor;
            colorTweenRef.current = gsap.to(btn, { color: targetColor, delay: 0.18, duration: 0.3, ease: 'power2.out' });
        } else { gsap.set(btn, { color: menuButtonColor }); }
    }, [openMenuButtonColor, menuButtonColor, changeMenuColorOnOpen]);

    React.useEffect(() => {
        if (toggleBtnRef.current) {
            if (changeMenuColorOnOpen) {
                const targetColor = isOpen ? openMenuButtonColor : menuButtonColor;
                gsap.set(toggleBtnRef.current, { color: targetColor });
            } else { gsap.set(toggleBtnRef.current, { color: menuButtonColor }); }
        }
    }, [changeMenuColorOnOpen, menuButtonColor, openMenuButtonColor, isOpen]);

    const animateText = useCallback((opening: boolean) => {
        const inner = textInnerRef.current; if (!inner) return;
        textCycleAnimRef.current?.kill();
        const targetLabel = opening ? 'Close' : 'Menu'; setTextLines(['Menu', 'Close']);
        gsap.set(inner, { yPercent: targetLabel === 'Close' ? 0 : -50 });
        textCycleAnimRef.current = gsap.to(inner, { yPercent: targetLabel === 'Close' ? -50 : 0, duration: 0.5, ease: 'power4.out' });
    }, []);

    useEffect(() => {
        if (!isMounted.current) {
            isMounted.current = true;
            if (!isOpen) return;
        }

        if (isOpen) {
            onMenuOpen?.();
            playOpen();
        } else {
            onMenuClose?.();
            playClose();
        }
        animateIcon(isOpen);
        animateColor(isOpen);
        animateText(isOpen);
    }, [isOpen, onMenuOpen, onMenuClose, playOpen, playClose, animateIcon, animateColor, animateText]);


    const wrapperStyle: React.CSSProperties = { pointerEvents: isOpen ? 'auto' : 'none' };
    if (isFixed) {
        Object.assign(wrapperStyle, { position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh' });
    } else {
        Object.assign(wrapperStyle, { position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' });
    }

    return (
        <div className="sm-scope z-50" style={wrapperStyle}>
            {isDesktop && isOpen && <TargetCursor targetSelector=".sm-panel-item, .sm-socials-link, .sm-toggle" initialPos={initialCursorPos} />}
            <div className={(className ? className + ' ' : '') + 'staggered-menu-wrapper relative w-full h-full z-40'} style={accentColor ? ({ ['--sm-accent']: accentColor } as React.CSSProperties) : undefined} data-position={position} data-open={isOpen || undefined}>
                <div ref={preLayersRef} className="sm-prelayers absolute top-0 right-0 bottom-0 pointer-events-none z-[5]" aria-hidden="true">
                    {(() => {
                        const baseColors = colors && colors.length ? colors.slice(0, 3) : ['#1e1e22', '#35353c'];
                        const allColors = accentColor ? [accentColor, ...baseColors] : baseColors;
                        return allColors.map((c, i) => (<div key={i} className="sm-prelayer absolute top-0 right-0 h-full w-full translate-x-0" style={{ background: c }} />));
                    })()}
                </div>
                <header ref={headerRef} className="staggered-menu-header absolute top-0 left-0 w-full flex items-center justify-between p-[2em] bg-transparent pointer-events-none z-20" aria-label="Main navigation header">
                    <div className="sm-logo flex items-center select-none pointer-events-auto" aria-label="Logo">
                        {logo}
                    </div>
                    <button ref={toggleBtnRef} className="sm-toggle group relative inline-flex items-center gap-[0.3rem] bg-transparent border-0 font-medium leading-none overflow-visible pointer-events-auto" aria-label={isOpen ? 'Close menu' : 'Open menu'} aria-expanded={isOpen} aria-controls="staggered-menu-panel" onClick={onToggle} type="button">
                        <span className="sm-toggle-textWrap relative inline-block h-[1em] overflow-hidden whitespace-nowrap w-[3em] transition-transform duration-200 group-hover:-translate-x-1" aria-hidden="true">
                            <span ref={textInnerRef} className="sm-toggle-textInner flex flex-col leading-none">
                                {textLines.map((l, i) => (<span className="sm-toggle-line block h-[1em] leading-none" key={i}>{l}</span>))}
                            </span>
                        </span>
                        <span ref={iconRef} className="sm-icon relative w-[14px] h-[14px] shrink-0 inline-flex items-center justify-center [will-change:transform] transition-transform duration-200 group-hover:scale-125" aria-hidden="true">
                            <span ref={plusHRef} className="sm-icon-line absolute left-1/2 top-1/2 w-full h-[2px] bg-current rounded-[2px] -translate-x-1/2 -translate-y-1/2 [will-change:transform]" />
                            <span ref={plusVRef} className="sm-icon-line sm-icon-line-v absolute left-1/2 top-1/2 w-full h-[2px] bg-current rounded-[2px] -translate-x-1/2 -translate-y-1/2 [will-change:transform]" />
                        </span>
                    </button>
                </header>
                <aside id="staggered-menu-panel" ref={panelRef} className="staggered-menu-panel absolute top-0 right-0 h-full bg-zinc-950/95 flex flex-col p-[6em_2em_2em_2em] overflow-y-auto z-10 backdrop-blur-xl" aria-hidden={!isOpen}>
                    <div className="sm-panel-inner flex-1 flex flex-col gap-5">
                        <ul className="sm-panel-list list-none m-0 p-0 flex flex-col gap-2" role="list" data-numbering={displayItemNumbering || undefined}>
                            {items && items.length > 0 ? (
                                items.map((it, idx) => (
                                    <li className="sm-panel-itemWrap relative overflow-hidden leading-none" key={it.label + idx}>
                                        <NavLink className="sm-panel-item" to={it.link} aria-label={it.ariaLabel} data-index={idx + 1} onClick={onClose}>
                                            <span className="sm-panel-itemLabel inline-block [transform-origin:50%_100%] will-change-transform">{it.label}</span>
                                        </NavLink>
                                    </li>
                                ))
                            ) : (<li className="sm-panel-itemWrap relative overflow-hidden leading-none" aria-hidden="true"><span className="sm-panel-item"><span className="sm-panel-itemLabel">No items</span></span></li>)}
                        </ul>
                        {displaySocials && socialItems && socialItems.length > 0 && (
                            <div className="sm-socials mt-auto pt-8 flex flex-col gap-3" aria-label="Social links">
                                <h3 className="sm-socials-title">Socials</h3>
                                <ul className="sm-socials-list list-none m-0 p-0 flex flex-row items-center gap-4 flex-wrap" role="list">
                                    {socialItems.map((s, i) => (<li key={s.label + i} className="sm-socials-item"><a href={s.link} target="_blank" rel="noopener noreferrer" className="sm-socials-link">{s.label}</a></li>))}
                                </ul>
                            </div>
                        )}
                    </div>
                </aside>
            </div>
            <style>{`.sm-scope .sm-panel-item { position: relative; color: #a1a1aa; font-weight: 600; font-size: 4rem; line-height: 1; letter-spacing: -2px; text-transform: uppercase; transition: background 0.25s, color 0.25s; display: inline-block; text-decoration: none; padding-right: 1.4em; } .sm-scope .sm-panel-item:hover { color: var(--sm-accent, #FAFAFA); } .sm-scope .sm-panel-list[data-numbering] { counter-reset: smItem; } .sm-scope .sm-panel-list[data-numbering] .sm-panel-item::after { counter-increment: smItem; content: counter(smItem, decimal-leading-zero); position: absolute; top: 0.1em; right: 0; font-size: 18px; font-weight: 400; color: var(--sm-accent, #FAFAFA); letter-spacing: 0; pointer-events: none; user-select: none; opacity: var(--sm-num-opacity, 0); } @media (max-width: 640px) { .sm-scope .sm-panel-item {font-size: 3rem;} } .sm-socials-title { margin: 0; font-size: 1rem; font-weight: 500; color: var(--sm-accent, #FAFAFA); } .sm-socials-link { font-size: 1.2rem; font-weight: 500; color: #a1a1aa; text-decoration: none; position: relative; padding: 2px 0; display: inline-block; transition: color 0.3s ease, opacity 0.3s ease; }`}</style>
        </div>
    );
};
export default StaggeredMenu;
--- END OF FILE src/components/bits/StaggeredMenu.tsx ---

--- START OF FILE src/components/bits/TargetCursor.tsx ---
import React, { useEffect, useRef, useCallback, useMemo } from 'react';
import { gsap } from 'gsap';

export interface TargetCursorProps {
    targetSelector?: string;
    spinDuration?: number;
    hideDefaultCursor?: boolean;
    initialPos?: { x: number; y: number };
}

const TargetCursor: React.FC<TargetCursorProps> = ({
    targetSelector = '.cursor-target',
    spinDuration = 2,
    hideDefaultCursor = true,
    initialPos,
}) => {
    const cursorRef = useRef<HTMLDivElement>(null);
    const cornersRef = useRef<NodeListOf<HTMLDivElement> | null>(null);
    const spinTl = useRef<gsap.core.Timeline | null>(null);
    const dotRef = useRef<HTMLDivElement>(null);
    const constants = useMemo(
        () => ({
            borderWidth: 3,
            cornerSize: 12,
            parallaxStrength: 0.00005
        }),
        []
    );

    const moveCursor = useCallback((x: number, y: number) => {
        if (!cursorRef.current) return;
        gsap.to(cursorRef.current, {
            x,
            y,
            duration: 0.1,
            ease: 'power3.out'
        });
    }, []);

    useEffect(() => {
        if (hideDefaultCursor) {
            const style = document.createElement('style');
            style.id = 'target-cursor-style';
            style.innerHTML = `* { cursor: none !important; }`;
            document.head.appendChild(style);

            return () => {
                const styleElement = document.getElementById('target-cursor-style');
                if (styleElement) {
                    document.head.removeChild(styleElement);
                }
            };
        }
    }, [hideDefaultCursor]);

    useEffect(() => {
        if (!cursorRef.current) return;

        const cursor = cursorRef.current;
        cornersRef.current = cursor.querySelectorAll<HTMLDivElement>('.target-cursor-corner');

        let activeTarget: Element | null = null;
        let currentTargetMove: ((ev: Event) => void) | null = null;
        let currentLeaveHandler: (() => void) | null = null;
        let isAnimatingToTarget = false;
        let resumeTimeout: ReturnType<typeof setTimeout> | null = null;

        const cleanupTarget = (target: Element) => {
            if (currentTargetMove) {
                target.removeEventListener('mousemove', currentTargetMove);
            }
            if (currentLeaveHandler) {
                target.removeEventListener('mouseleave', currentLeaveHandler);
            }
            currentTargetMove = null;
            currentLeaveHandler = null;
        };

        gsap.set(cursor, {
            xPercent: -50,
            yPercent: -50,
            x: initialPos ? initialPos.x : window.innerWidth / 2,
            y: initialPos ? initialPos.y : window.innerHeight / 2,
        });

        const createSpinTimeline = () => {
            if (spinTl.current) {
                spinTl.current.kill();
            }
            spinTl.current = gsap
                .timeline({ repeat: -1 })
                .to(cursor, { rotation: '+=360', duration: spinDuration, ease: 'none' });
        };

        createSpinTimeline();

        const moveHandler = (e: MouseEvent) => moveCursor(e.clientX, e.clientY);
        window.addEventListener('mousemove', moveHandler);

        const scrollHandler = () => {
            if (!activeTarget || !cursorRef.current) return;

            const mouseX = gsap.getProperty(cursorRef.current, 'x') as number;
            const mouseY = gsap.getProperty(cursorRef.current, 'y') as number;

            const elementUnderMouse = document.elementFromPoint(mouseX, mouseY);
            const isStillOverTarget =
                elementUnderMouse &&
                (elementUnderMouse === activeTarget || elementUnderMouse.closest(targetSelector) === activeTarget);

            if (!isStillOverTarget) {
                if (currentLeaveHandler) {
                    currentLeaveHandler();
                }
            }
        };

        window.addEventListener('scroll', scrollHandler, { passive: true });

        const mouseDownHandler = (): void => {
            if (!dotRef.current) return;
            gsap.to(dotRef.current, { scale: 0.7, duration: 0.3 });
            gsap.to(cursorRef.current, { scale: 0.9, duration: 0.2 });
        };

        const mouseUpHandler = (): void => {
            if (!dotRef.current) return;
            gsap.to(dotRef.current, { scale: 1, duration: 0.3 });
            gsap.to(cursorRef.current, { scale: 1, duration: 0.2 });
        };

        window.addEventListener('mousedown', mouseDownHandler);
        window.addEventListener('mouseup', mouseUpHandler);

        const enterHandler = (e: MouseEvent) => {
            const directTarget = e.target as Element;

            const allTargets: Element[] = [];
            let current = directTarget;
            while (current && current !== document.body) {
                if (current.matches(targetSelector)) {
                    allTargets.push(current);
                }
                current = current.parentElement!;
            }

            const target = allTargets[0] || null;
            if (!target || !cursorRef.current || !cornersRef.current) return;

            if (activeTarget === target) return;

            if (activeTarget) {
                cleanupTarget(activeTarget);
            }

            if (resumeTimeout) {
                clearTimeout(resumeTimeout);
                resumeTimeout = null;
            }

            activeTarget = target;
            if (cornersRef.current) {
                const corners = Array.from(cornersRef.current);
                corners.forEach(corner => {
                    gsap.killTweensOf(corner);
                });
            }
            gsap.killTweensOf(cursorRef.current, 'rotation');
            spinTl.current?.pause();

            gsap.set(cursorRef.current, { rotation: 0 });

            const updateCorners = (mouseX?: number, mouseY?: number) => {
                if (!cursorRef.current || !cornersRef.current) return;
                const rect = target.getBoundingClientRect();
                const cursorRect = cursorRef.current.getBoundingClientRect();

                const cursorCenterX = cursorRect.left + cursorRect.width / 2;
                const cursorCenterY = cursorRect.top + cursorRect.height / 2;

                const [tlc, trc, brc, blc] = Array.from(cornersRef.current);

                const { borderWidth, cornerSize, parallaxStrength } = constants;

                const tlOffset = {
                    x: rect.left - cursorCenterX - borderWidth,
                    y: rect.top - cursorCenterY - borderWidth
                };
                const trOffset = {
                    x: rect.right - cursorCenterX + borderWidth - cornerSize,
                    y: rect.top - cursorCenterY - borderWidth
                };
                const brOffset = {
                    x: rect.right - cursorCenterX + borderWidth - cornerSize,
                    y: rect.bottom - cursorCenterY + borderWidth - cornerSize
                };
                const blOffset = {
                    x: rect.left - cursorCenterX - borderWidth,
                    y: rect.bottom - cursorCenterY + borderWidth - cornerSize
                };

                if (mouseX !== undefined && mouseY !== undefined) {
                    const targetCenterX = rect.left + rect.width / 2;
                    const targetCenterY = rect.top + rect.height / 2;
                    const mouseOffsetX = (mouseX - targetCenterX) * parallaxStrength;
                    const mouseOffsetY = (mouseY - targetCenterY) * parallaxStrength;

                    tlOffset.x += mouseOffsetX;
                    tlOffset.y += mouseOffsetY;
                    trOffset.x += mouseOffsetX;
                    trOffset.y += mouseOffsetY;
                    brOffset.x += mouseOffsetX;
                    brOffset.y += mouseOffsetY;
                    blOffset.x += mouseOffsetX;
                    blOffset.y += mouseOffsetY;
                }

                const tl = gsap.timeline();
                const corners = [tlc, trc, brc, blc];
                const offsets = [tlOffset, trOffset, brOffset, blOffset];

                corners.forEach((corner, index) => {
                    tl.to(
                        corner,
                        {
                            x: offsets[index].x,
                            y: offsets[index].y,
                            duration: 0.2,
                            ease: 'power2.out'
                        },
                        0
                    );
                });
            };

            isAnimatingToTarget = true;
            updateCorners();

            setTimeout(() => {
                isAnimatingToTarget = false;
            }, 1);

            let moveThrottle: number | null = null;
            const targetMove = (ev: Event) => {
                if (moveThrottle || isAnimatingToTarget) return;
                moveThrottle = requestAnimationFrame(() => {
                    const mouseEvent = ev as MouseEvent;
                    updateCorners(mouseEvent.clientX, mouseEvent.clientY);
                    moveThrottle = null;
                });
            };

            const leaveHandler = () => {
                activeTarget = null;
                isAnimatingToTarget = false;

                if (cornersRef.current) {
                    const corners = Array.from(cornersRef.current);
                    gsap.killTweensOf(corners);

                    const { cornerSize } = constants;
                    const positions = [
                        { x: -cornerSize * 1.5, y: -cornerSize * 1.5 },
                        { x: cornerSize * 0.5, y: -cornerSize * 1.5 },
                        { x: cornerSize * 0.5, y: cornerSize * 0.5 },
                        { x: -cornerSize * 1.5, y: cornerSize * 0.5 }
                    ];

                    const tl = gsap.timeline();
                    corners.forEach((corner, index) => {
                        tl.to(
                            corner,
                            {
                                x: positions[index].x,
                                y: positions[index].y,
                                duration: 0.3,
                                ease: 'power3.out'
                            },
                            0
                        );
                    });
                }

                resumeTimeout = setTimeout(() => {
                    if (!activeTarget && cursorRef.current && spinTl.current) {
                        const currentRotation = gsap.getProperty(cursorRef.current, 'rotation') as number;
                        const normalizedRotation = currentRotation % 360;

                        spinTl.current.kill();
                        spinTl.current = gsap
                            .timeline({ repeat: -1 })
                            .to(cursorRef.current, { rotation: '+=360', duration: spinDuration, ease: 'none' });

                        gsap.to(cursorRef.current, {
                            rotation: normalizedRotation + 360,
                            duration: spinDuration * (1 - normalizedRotation / 360),
                            ease: 'none',
                            onComplete: () => {
                                spinTl.current?.restart();
                            }
                        });
                    }
                    resumeTimeout = null;
                }, 50);

                cleanupTarget(target);
            };

            currentTargetMove = targetMove;
            currentLeaveHandler = leaveHandler;

            target.addEventListener('mousemove', targetMove);
            target.addEventListener('mouseleave', leaveHandler);
        };

        window.addEventListener('mouseover', enterHandler, { passive: true });

        return () => {
            window.removeEventListener('mousemove', moveHandler);
            window.removeEventListener('mouseover', enterHandler);
            window.removeEventListener('scroll', scrollHandler);
            window.removeEventListener('mousedown', mouseDownHandler);
            window.removeEventListener('mouseup', mouseUpHandler);

            if (activeTarget) {
                cleanupTarget(activeTarget);
            }

            spinTl.current?.kill();
        };
    }, [targetSelector, spinDuration, moveCursor, constants, initialPos]);

    useEffect(() => {
        if (!cursorRef.current || !spinTl.current) return;

        if (spinTl.current.isActive()) {
            spinTl.current.kill();
            spinTl.current = gsap
                .timeline({ repeat: -1 })
                .to(cursorRef.current, { rotation: '+=360', duration: spinDuration, ease: 'none' });
        }
    }, [spinDuration]);

    return (
        <div
            ref={cursorRef}
            className="fixed top-0 left-0 w-0 h-0 pointer-events-none z-[9999] mix-blend-difference transform -translate-x-1/2 -translate-y-1/2"
            style={{ willChange: 'transform' }}
        >
            <div
                ref={dotRef}
                className="absolute left-1/2 top-1/2 w-1 h-1 bg-white rounded-full transform -translate-x-1/2 -translate-y-1/2"
                style={{ willChange: 'transform' }}
            />
            <div
                className="target-cursor-corner absolute left-1/2 top-1/2 w-3 h-3 border-[3px] border-white transform -translate-x-[150%] -translate-y-[150%] border-r-0 border-b-0"
                style={{ willChange: 'transform' }}
            />
            <div
                className="target-cursor-corner absolute left-1/2 top-1/2 w-3 h-3 border-[3px] border-white transform translate-x-1/2 -translate-y-[150%] border-l-0 border-b-0"
                style={{ willChange: 'transform' }}
            />
            <div
                className="target-cursor-corner absolute left-1/2 top-1/2 w-3 h-3 border-[3px] border-white transform translate-x-1/2 translate-y-1/2 border-l-0 border-t-0"
                style={{ willChange: 'transform' }}
            />
            <div
                className="target-cursor-corner absolute left-1/2 top-1/2 w-3 h-3 border-[3px] border-white transform -translate-x-[150%] translate-y-1/2 border-r-0 border-t-0"
                style={{ willChange: 'transform' }}
            />
        </div>
    );
};

export default TargetCursor;
--- END OF FILE src/components/bits/TargetCursor.tsx ---

--- START OF FILE src/components/ui/blurry-button.tsx ---
import * as React from 'react';
import { cn } from '@/lib/utils';

const BlurryButton = React.forwardRef<
    HTMLButtonElement,
    React.ButtonHTMLAttributes<HTMLButtonElement>
>(({ className, children, ...props }, ref) => {
    const internalRef = React.useRef<HTMLButtonElement>(null);

    React.useImperativeHandle(ref, () => internalRef.current!);

    const handleMouseMove = (e: React.MouseEvent<HTMLButtonElement>) => {
        const button = internalRef.current;
        if (!button) return;

        const rect = button.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        button.style.setProperty('--mouse-x', `${x}px`);
        button.style.setProperty('--mouse-y', `${y}px`);
    };

    return (
        <button
            className={cn(
                // Base styles
                'relative inline-flex items-center justify-center whitespace-nowrap rounded-full px-8 py-2 text-base font-medium text-foreground transition-colors overflow-hidden',

                // Glass effect
                'bg-black/20 backdrop-blur-sm',

                // Glassy border
                'border border-white/20 shadow-[inset_0_1px_0_0_rgba(255,255,255,0.05)]',

                // Hover and focus states
                'hover:bg-black/30',
                'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 ring-offset-background',

                // Disabled state
                'disabled:pointer-events-none disabled:opacity-50',

                // Pseudo-element for the mouse-reactive highlight
                "before:content-[''] before:absolute before:inset-0 before:rounded-full",
                'before:opacity-0 hover:before:opacity-100 before:transition-opacity before:duration-300',
                "before:bg-[radial-gradient(circle_at_var(--mouse-x)_var(--mouse-y),rgba(255,255,255,0.15)_0%,transparent_70%)]",

                className
            )}
            ref={internalRef}
            onMouseMove={handleMouseMove}
            {...props}
        >
            {children}
        </button>
    );
});
BlurryButton.displayName = 'BlurryButton';

export { BlurryButton };
--- END OF FILE src/components/ui/blurry-button.tsx ---

--- START OF FILE src/components/ui/button.tsx ---
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

--- END OF FILE src/components/ui/button.tsx ---

--- START OF FILE src/components/ui/card.tsx ---
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

--- END OF FILE src/components/ui/card.tsx ---

--- START OF FILE src/components/ui/color-picker.tsx ---
'use client';

import Color from 'color';
import { PipetteIcon } from 'lucide-react';
import * as Slider from '@radix-ui/react-slider';
import {
    type ComponentProps,
    createContext,
    type HTMLAttributes,
    memo,
    useCallback,
    useContext,
    useEffect,
    useRef,
    useState,
} from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from '@/components/ui/select';
import { cn } from '@/lib/utils';

// Use InstanceType to get the type of a Color instance
type ColorInstance = InstanceType<typeof Color>;

interface ColorPickerContextValue {
    color: ColorInstance;
    mode: string;
    setColor: (color: ColorInstance) => void;
    setMode: (mode: string) => void;
}

const ColorPickerContext = createContext<ColorPickerContextValue | undefined>(
    undefined
);

// eslint-disable-next-line react-refresh/only-export-components
export const useColorPicker = () => {
    const context = useContext(ColorPickerContext);
    if (!context) {
        throw new Error('useColorPicker must be used within a ColorPickerProvider');
    }
    return context;
};

// Omit conflicting `onChange` from HTMLAttributes and define our own
export type ColorPickerProps = Omit<HTMLAttributes<HTMLDivElement>, 'onChange'> & {
    value?: string;
    defaultValue?: string;
    onChange?: (value: string) => void;
};

export const ColorPicker = ({
    value,
    defaultValue = '#000000',
    onChange,
    className,
    ...props
}: ColorPickerProps) => {
    const [colorState, setColorState] = useState(() => Color(value ?? defaultValue));
    const [mode, setMode] = useState('hex');

    useEffect(() => {
        if (value) {
            try {
                setColorState(Color(value));
            } catch {
                // ignore invalid color
            }
        }
    }, [value]);

    const setColor = (newColor: ColorInstance) => {
        setColorState(newColor);
        if (onChange) {
            onChange(newColor.hexa());
        }
    };

    return (
        <ColorPickerContext.Provider
            value={{
                color: colorState,
                mode,
                setColor,
                setMode,
            }}
        >
            <div
                className={cn('flex size-full flex-col gap-4', className)}
                {...props}
            />
        </ColorPickerContext.Provider>
    );
};

export type ColorPickerSelectionProps = HTMLAttributes<HTMLDivElement>;

export const ColorPickerSelection = memo(
    ({ className, ...props }: ColorPickerSelectionProps) => {
        const containerRef = useRef<HTMLDivElement>(null);
        const [isDragging, setIsDragging] = useState(false);
        const { color, setColor } = useColorPicker();
        const { h, s, v } = color.hsv().object();

        const handlePointerMove = useCallback(
            (event: PointerEvent | React.PointerEvent<HTMLDivElement>) => {
                if (!containerRef.current) return;
                const rect = containerRef.current.getBoundingClientRect();
                const x = Math.max(0, Math.min(rect.width, event.clientX - rect.left));
                const y = Math.max(0, Math.min(rect.height, event.clientY - rect.top));

                const newSaturation = (x / rect.width) * 100;
                const newValue = 100 - (y / rect.height) * 100;

                setColor(Color({ h, s: newSaturation, v: newValue }));
            },
            [h, setColor]
        );

        useEffect(() => {
            const handlePointerUp = () => setIsDragging(false);
            if (isDragging) {
                document.addEventListener('pointermove', handlePointerMove);
                document.addEventListener('pointerup', handlePointerUp);
            }
            return () => {
                document.removeEventListener('pointermove', handlePointerMove);
                document.removeEventListener('pointerup', handlePointerUp);
            };
        }, [isDragging, handlePointerMove]);

        return (
            <div
                className={cn('relative size-full cursor-crosshair rounded', className)}
                onPointerDown={(e) => {
                    e.preventDefault();
                    setIsDragging(true);
                    handlePointerMove(e.nativeEvent);
                }}
                ref={containerRef}
                style={{
                    backgroundColor: `hsl(${h}, 100%, 50%)`,
                }}
                {...props}
            >
                <div
                    className="h-full w-full"
                    style={{
                        backgroundImage: `linear-gradient(to top, black, transparent), linear-gradient(to right, white, transparent)`
                    }}
                >
                    <div
                        className="-translate-x-1/2 -translate-y-1/2 pointer-events-none absolute h-4 w-4 rounded-full border-2 border-white"
                        style={{
                            left: `${s}%`,
                            top: `${100 - v}%`,
                            boxShadow: '0 0 0 1px rgba(0,0,0,0.5)',
                            backgroundColor: color.hex()
                        }}
                    />
                </div>
            </div>
        );
    }
);

ColorPickerSelection.displayName = 'ColorPickerSelection';

export type ColorPickerHueProps = ComponentProps<typeof Slider.Root>;

export const ColorPickerHue = ({
    className,
    ...props
}: ColorPickerHueProps) => {
    const { color, setColor } = useColorPicker();
    const { h } = color.hsl().object();

    return (
        <Slider.Root
            className={cn('relative flex h-4 w-full touch-none items-center', className)}
            max={360}
            onValueChange={([hue]) => setColor(color.hue(hue))}
            step={1}
            value={[h]}
            {...props}
        >
            <Slider.Track className="relative my-0.5 h-3 w-full grow rounded-full bg-[linear-gradient(90deg,#FF0000,#FFFF00,#00FF00,#00FFFF,#0000FF,#FF00FF,#FF0000)]" />
            <Slider.Thumb className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" />
        </Slider.Root>
    );
};

export type ColorPickerAlphaProps = ComponentProps<typeof Slider.Root>;

export const ColorPickerAlpha = ({
    className,
    ...props
}: ColorPickerAlphaProps) => {
    const { color, setColor } = useColorPicker();
    const { r, g, b } = color.rgb().object();
    const a = color.alpha();

    return (
        <Slider.Root
            className={cn('relative flex h-4 w-full items-center touch-none', className)}
            max={1}
            onValueChange={([alpha]) => setColor(color.alpha(alpha))}
            step={0.01}
            value={[a]}
            {...props}
        >
            <Slider.Track
                className="relative my-0.5 h-3 w-full grow rounded-full"
                style={{
                    background:
                        'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVQ4T2NkYGAQYcAP3uCTZhw1gGGYhAGBZIA/nYDCgBDAm9BGDWAAJyRCgLaBCAAgXwixzAS0pgAAAABJRU5ErkJggg==") left center',
                }}
            >
                <div className="absolute inset-0 rounded-full" style={{ background: `linear-gradient(to right, transparent, rgb(${r}, ${g}, ${b}))` }} />
            </Slider.Track>
            <Slider.Thumb className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" />
        </Slider.Root>
    );
};

export type ColorPickerEyeDropperProps = ComponentProps<typeof Button>;

export const ColorPickerEyeDropper = ({
    className,
    ...props
}: ColorPickerEyeDropperProps) => {
    const { setColor } = useColorPicker();

    const handleEyeDropper = async () => {
        try {
            // @ts-expect-error - EyeDropper API is experimental
            const eyeDropper = new EyeDropper();
            const result = await eyeDropper.open();
            setColor(Color(result.sRGBHex));
        } catch (error) {
            console.error('EyeDropper failed:', error);
        }
    };

    return (
        <Button
            className={cn('shrink-0 text-muted-foreground', className)}
            onClick={handleEyeDropper}
            size="icon"
            variant="outline"
            type="button"
            {...props}
        >
            <PipetteIcon size={16} />
        </Button>
    );
};

export type ColorPickerOutputProps = ComponentProps<typeof SelectTrigger>;

const formats = ['hex', 'rgb', 'hsl'];

export const ColorPickerOutput = ({
    className,
    ...props
}: ColorPickerOutputProps) => {
    const { mode, setMode } = useColorPicker();

    return (
        <Select onValueChange={setMode} value={mode}>
            <SelectTrigger className={cn("h-8 w-20 shrink-0 text-xs", className)} {...props}>
                <SelectValue placeholder="Mode" />
            </SelectTrigger>
            <SelectContent>
                {formats.map((format) => (
                    <SelectItem className="text-xs" key={format} value={format}>
                        {format.toUpperCase()}
                    </SelectItem>
                ))}
            </SelectContent>
        </Select>
    );
};

export type ColorPickerFormatProps = Omit<HTMLAttributes<HTMLDivElement>, 'onChange'>;

export const ColorPickerFormat = ({
    className,
    ...props
}: ColorPickerFormatProps) => {
    const { color, mode, setColor } = useColorPicker();
    const [inputValue, setInputValue] = useState(color.hex());

    const formatValue = useCallback(() => {
        switch (mode) {
            case 'hex':
                return color.hexa();
            case 'rgb':
                return color.rgb().string();
            case 'hsl':
                return color.hsl().string();
            default:
                return color.hexa();
        }
    }, [color, mode]);

    useEffect(() => {
        setInputValue(formatValue());
    }, [color, mode, formatValue]);

    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const text = e.target.value;
        setInputValue(text);
        try {
            setColor(Color(text));
        } catch {
            // Ignore invalid color strings
        }
    }

    return (
        <div className={cn('w-full rounded-md shadow-sm', className)} {...props}>
            <Input
                className="h-8 w-full bg-secondary px-2 text-xs shadow-none"
                type="text"
                value={inputValue}
                onChange={handleInputChange}
            />
        </div>
    );
};
--- END OF FILE src/components/ui/color-picker.tsx ---

--- START OF FILE src/components/ui/dialog.tsx ---
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Overlay>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
    <DialogPrimitive.Overlay
        ref={ref}
        className={cn(
            "fixed inset-0 z-50 bg-black/50 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
            className
        )}
        {...props}
    />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
    <DialogPortal>
        <DialogOverlay />
        <DialogPrimitive.Content
            ref={ref}
            className={cn(
                "fixed left-1/2 top-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
                className
            )}
            {...props}
        >
            {children}
            <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
                <XIcon className="h-4 w-4" />
                <span className="sr-only">Close</span>
            </DialogPrimitive.Close>
        </DialogPrimitive.Content>
    </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
    className,
    ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
    <div
        className={cn(
            "flex flex-col space-y-1.5 text-center sm:text-left",
            className
        )}
        {...props}
    />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
    className,
    ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
    <div
        className={cn(
            "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
            className
        )}
        {...props}
    />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Title>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
    <DialogPrimitive.Title
        ref={ref}
        className={cn(
            "text-lg font-semibold leading-none tracking-tight",
            className
        )}
        {...props}
    />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Description>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
    <DialogPrimitive.Description
        ref={ref}
        className={cn("text-sm text-muted-foreground", className)}
        {...props}
    />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
    Dialog,
    DialogPortal,
    DialogOverlay,
    DialogClose,
    DialogTrigger,
    DialogContent,
    DialogHeader,
    DialogFooter,
    DialogTitle,
    DialogDescription,
}
--- END OF FILE src/components/ui/dialog.tsx ---

--- START OF FILE src/components/ui/download-button.tsx ---
import { FC } from 'react';
import { Download, FileDown } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';

type DownloadFormat = 'png' | 'jpeg' | 'svg';

interface DownloadButtonProps {
    onDownload: (format: DownloadFormat) => void;
    disabled?: boolean;
}

export const DownloadButton: FC<DownloadButtonProps> = ({ onDownload, disabled = false }) => {
    return (
        <Popover>
            <PopoverTrigger asChild>
                <Button disabled={disabled}>
                    <Download className="mr-2 h-4 w-4" />
                    Download
                </Button>
            </PopoverTrigger>
            <PopoverContent className="w-40 p-2">
                <div className="grid gap-1">
                    <Button
                        variant="ghost"
                        className="w-full justify-start"
                        onClick={() => onDownload('png')}
                    >
                        <FileDown className="mr-2 h-4 w-4" />
                        PNG
                    </Button>
                    <Button
                        variant="ghost"
                        className="w-full justify-start"
                        onClick={() => onDownload('jpeg')}
                    >
                        <FileDown className="mr-2 h-4 w-4" />
                        JPG
                    </Button>
                    <Button
                        variant="ghost"
                        className="w-full justify-start"
                        onClick={() => onDownload('svg')}
                    >
                        <FileDown className="mr-2 h-4 w-4" />
                        SVG
                    </Button>
                </div>
            </PopoverContent>
        </Popover>
    );
};
--- END OF FILE src/components/ui/download-button.tsx ---

--- START OF FILE src/components/ui/input.tsx ---
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

--- END OF FILE src/components/ui/input.tsx ---

--- START OF FILE src/components/ui/label.tsx ---
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

--- END OF FILE src/components/ui/label.tsx ---

--- START OF FILE src/components/ui/popover.tsx ---
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
    React.ElementRef<typeof PopoverPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
    <PopoverPrimitive.Portal>
        <PopoverPrimitive.Content
            ref={ref}
            align={align}
            sideOffset={sideOffset}
            className={cn(
                "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
                className
            )}
            {...props}
        />
    </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
--- END OF FILE src/components/ui/popover.tsx ---

--- START OF FILE src/components/ui/select.tsx ---
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

--- END OF FILE src/components/ui/select.tsx ---

--- START OF FILE src/components/ui/separator.tsx ---
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

--- END OF FILE src/components/ui/separator.tsx ---

--- START OF FILE src/components/ui/sheet.tsx ---
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

--- END OF FILE src/components/ui/sheet.tsx ---

--- START OF FILE src/components/ui/slider.tsx ---
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary ring-ring/50 block size-4 shrink-0 rounded-full border bg-white shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }

--- END OF FILE src/components/ui/slider.tsx ---

--- START OF FILE src/components/ui/textarea.tsx ---
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }

--- END OF FILE src/components/ui/textarea.tsx ---

--- START OF FILE src/hooks/useFontLoader.ts ---
import { useState, useEffect } from 'react';

export const useFontLoader = (fontFamily: string) => {
    const [isLoaded, setIsLoaded] = useState(false);

    useEffect(() => {
        let isCancelled = false;

        if (document.fonts.check(`1em ${fontFamily}`)) {
            setIsLoaded(true);
            return;
        }

        document.fonts.load(`1em ${fontFamily}`)
            .then(() => {
                if (!isCancelled) {
                    setIsLoaded(true);
                }
            })
            .catch((err) => {
                console.error(`Failed to load font: ${fontFamily}`, err);
            });

        return () => {
            isCancelled = true;
        };
    }, [fontFamily]);

    return isLoaded;
};
--- END OF FILE src/hooks/useFontLoader.ts ---

--- START OF FILE src/lib/utils.ts ---
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--- END OF FILE src/lib/utils.ts ---

--- START OF FILE src/pages/HomePage.tsx ---
import { useState, useEffect } from 'react';
import { useOutletContext } from 'react-router-dom';
import { LayoutContext } from '@/components/Layout';
import ShinyText from '@/components/bits/ShinyText';
import { BlurryButton } from '@/components/ui/blurry-button';
import CircularText from '@/components/bits/CircularText';
import { motion } from 'motion/react';

const containerVariants = {
    hidden: {},
    visible: {
        transition: {
            staggerChildren: 0.2,
            delayChildren: 0.8,
        },
    },
};

const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
        opacity: 1,
        y: 0,
        transition: {
            duration: 1,
            ease: [0.3, 1, 0.5, 1] as [number, number, number, number]
        }
    },
};

export const HomePage = () => {
    const { openMenu } = useOutletContext<LayoutContext>();
    const [pageLoaded, setPageLoaded] = useState(false);

    useEffect(() => {
        // Wait half a second before triggering any animations
        const timer = setTimeout(() => {
            setPageLoaded(true);
        }, 500);

        return () => clearTimeout(timer);
    }, []);

    return (
        <>
            {/* Black overlay that fades out after 500ms */}
            <div
                className="fixed inset-0 bg-black pointer-events-none transition-opacity duration-1000 ease-out z-40"
                style={{ opacity: pageLoaded ? 0 : 1 }}
            />

            <motion.div
                className="container mx-auto h-full flex flex-col items-center justify-center text-center flex-1"
                variants={containerVariants}
                initial="hidden"
                animate="visible"
            >
                <motion.div variants={itemVariants}>
                    <ShinyText
                        text="Essential Online Tools"
                        className="text-4xl sm:text-5xl lg:text-6xl font-extrabold tracking-tight"
                    />
                </motion.div>
                <motion.p variants={itemVariants} className="max-w-lg mx-auto mt-4 text-lg sm:text-xl text-muted-foreground">
                    A collection of free and simple web utilities for everyday tasks, right in your browser.
                </motion.p>
                <motion.div variants={itemVariants} className="mt-7">
                    <BlurryButton onClick={openMenu}>
                        Discover Tools
                    </BlurryButton>
                </motion.div>
            </motion.div>

            <motion.div
                className="fixed bottom-8 right-8 hidden lg:block z-30"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ duration: 0.8, delay: 2.0 }}
            >
                <CircularText
                    text="VISIT GITHUB * VISIT GITHUB * "
                    href="https://github.com/SoldatenEnte"
                    spinDuration={25}
                    onHover="speedUp"
                />
            </motion.div>
        </>
    );
};
--- END OF FILE src/pages/HomePage.tsx ---

--- START OF FILE src/pages/NotFoundPage.tsx ---
import { useEffect } from 'react';
import { motion, useAnimation } from 'motion/react';
import FuzzyText from '@/components/bits/FuzzyText';
import Silk from '@/components/bits/Silk';
import { useFontLoader } from '@/hooks/useFontLoader';

export const NotFoundPage = () => {
    const isChewyLoaded = useFontLoader('Chewy');
    const chewyControls = useAnimation();

    useEffect(() => {
        if (isChewyLoaded) {
            chewyControls.start({ opacity: 1, y: 0 });
        }
    }, [isChewyLoaded, chewyControls]);

    return (
        <div className="relative w-full h-full flex flex-col items-center justify-center text-center">
            <div className="fixed inset-0 -z-10">
                <Silk
                    speed={5}
                    scale={1}
                    color="#1b1b1bff"
                    noiseIntensity={1.2}
                    rotation={0.1}
                />
            </div>
            <motion.div
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.5, ease: 'easeOut', delay: 0.2 }}
            >
                <FuzzyText
                    baseIntensity={0.2}
                    hoverIntensity={0.5}
                    enableHover={true}
                    fontSize="clamp(4rem, 12vw, 12rem)"
                    fontWeight="900"
                >
                    404
                </FuzzyText>
            </motion.div>
            <motion.div
                className="mt-3 ml-25 -rotate-6"
                initial={{ opacity: 0, y: 20 }}
                animate={chewyControls}
                transition={{ duration: 0.5, ease: 'easeOut' }}
            >
                <FuzzyText
                    baseIntensity={0.15}
                    hoverIntensity={0.4}
                    enableHover={true}
                    fontSize="clamp(1rem, 3vw, 3rem)"
                    fontWeight="400"
                    fontFamily='"Chewy", cursive'
                >
                    not found
                </FuzzyText>
            </motion.div>
        </div>
    );
};
--- END OF FILE src/pages/NotFoundPage.tsx ---

--- START OF FILE src/pages/tools/PlaceholderTool.tsx ---
import { Card, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Wrench } from "lucide-react";
import { motion } from "motion/react";

interface PlaceholderToolProps {
    toolName: string;
}

export const PlaceholderTool = ({ toolName }: PlaceholderToolProps) => {
    return (
        <motion.div
            className="flex items-center justify-center h-full"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5, ease: [0.4, 0, 0.2, 1] as const }}
        >
            <Card className="bg-card/60 border-white/10 backdrop-blur-xl text-center p-8 w-full max-w-lg">
                <CardHeader>
                    <div className="flex justify-center mb-4">
                        <Wrench className="h-12 w-12 text-primary" />
                    </div>
                    <CardTitle className="text-3xl font-bold">{toolName}</CardTitle>
                    <CardDescription className="text-lg text-muted-foreground mt-2">
                        This tool is currently under construction. Please check back later!
                    </CardDescription>
                </CardHeader>
            </Card>
        </motion.div>
    );
};
--- END OF FILE src/pages/tools/PlaceholderTool.tsx ---

--- START OF FILE src/pages/tools/QRCodeGenerator.tsx ---
import { useState, useRef, useEffect, ChangeEvent, RefObject, FC } from 'react';
import { QRCodeSVG } from 'qrcode.react';
import { Palette, Image as ImageIcon, Trash2, Type, Link, UploadCloud, AlertTriangle } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Separator } from '@/components/ui/separator';
import { Slider } from '@/components/ui/slider';
import { Textarea } from '@/components/ui/textarea';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import {
    ColorPicker,
    ColorPickerSelection,
    ColorPickerHue,
    ColorPickerAlpha,
    ColorPickerEyeDropper,
    ColorPickerOutput,
    ColorPickerFormat
} from '@/components/ui/color-picker';
import { cn } from '@/lib/utils';
import PixelBlast from '@/components/bits/PixelBlast';
import ErrorBoundary from '@/components/ErrorBoundary';
import { DownloadButton } from '@/components/ui/download-button';

type Level = 'L' | 'M' | 'Q' | 'H';

// --- Type Definitions for Component Props ---
interface QrCodeOptions {
    value: string;
    size: number;
    fgColor: string;
    bgColor: string;
    level: Level;
    imageSettings?: {
        src: string;
        height: number;
        width: number;
        excavate: boolean;
    };
}
interface QrCodePreviewProps {
    qrRef: RefObject<HTMLDivElement | null>;
    options: QrCodeOptions;
    size: number;
    onSizeChange: (size: number) => void;
    onFormatSelect: (format: 'png' | 'jpeg' | 'svg') => void;
    isTooLong: boolean;
    className?: string;
    delay?: number;
}
interface QrCodeControlsProps {
    text: string;
    onTextChange: (value: string) => void;
    level: Level;
    onLevelChange: (value: string) => void;
    fgColor: string;
    onFgColorChange: (value: string) => void;
    bgColor: string;
    onBgColorChange: (value: string) => void;
    onImageUpload: (event: ChangeEvent<HTMLInputElement>) => void;
    logoUrl: string;
    onLogoUrlChange: (value: string) => void;
    onRemoveLogo: () => void;
    finalLogoSrc: string;
    className?: string;
    delay?: number;
}

// --- Custom Hook ---
const useDebounce = <T,>(value: T, delay: number): T => {
    const [debouncedValue, setDebouncedValue] = useState<T>(value);
    useEffect(() => {
        const handler = setTimeout(() => setDebouncedValue(value), delay);
        return () => clearTimeout(handler);
    }, [value, delay]);
    return debouncedValue;
};

// --- Fade-in Animation Hook ---
const useFadeIn = (delay: number = 0) => {
    const [isVisible, setIsVisible] = useState(false);

    useEffect(() => {
        const timer = setTimeout(() => {
            setIsVisible(true);
        }, delay);

        return () => clearTimeout(timer);
    }, [delay]);

    return isVisible;
};

// --- Sub-Components with Typed Props ---
const QrErrorFallback = () => (
    <div className="flex flex-col items-center justify-center h-full text-center text-destructive p-4 bg-destructive/10 rounded-lg">
        <AlertTriangle className="w-10 h-10 mb-3" />
        <p className="font-semibold">Data Too Long</p>
        <p className="text-sm text-destructive/80">
            The input data is too long to be encoded in a QR code with the current settings. Try shortening the text or lowering the error correction level.
        </p>
    </div>
);

const QrCodePreview: FC<QrCodePreviewProps> = ({ qrRef, options, size, onSizeChange, onFormatSelect, isTooLong, className, delay = 0 }) => {
    const isVisible = useFadeIn(delay);

    return (
        <Card
            style={{ opacity: 0, backgroundColor: 'transparent' }}
            className={cn(
                "lg:col-span-2 flex flex-col items-center justify-start border-white/10 p-6 sm:p-8 h-full transition-all duration-1000 ease-out",
                isVisible
                    ? "!opacity-100 bg-black/20 backdrop-blur-lg translate-y-0"
                    : "!opacity-0 bg-transparent backdrop-blur-none translate-y-8",
                className
            )}
        >
            <div className="flex-grow w-full flex items-center justify-center min-h-0">
                <div ref={qrRef} className="p-4 bg-white shadow-lg rounded-lg transition-all w-full max-w-[400px] aspect-square">
                    {isTooLong ? (
                        <QrErrorFallback />
                    ) : (
                        <ErrorBoundary fallback={<QrErrorFallback />}>
                            <QRCodeSVG {...options} style={{ width: '100%', height: '100%' }} />
                        </ErrorBoundary>
                    )}
                </div>
            </div>
            <div className="w-full max-w-xs mt-8 flex-shrink-0">
                <Label className="block text-center text-sm font-medium text-foreground mb-3">Resolution: {size}px</Label>
                <Slider value={[size]} onValueChange={([val]) => onSizeChange(val)} min={64} max={2048} step={8} />
            </div>
            <div className="mt-6 flex items-center gap-2 sm:gap-4 flex-shrink-0 flex-wrap justify-center">
                <DownloadButton onDownload={onFormatSelect} disabled={!options.value || isTooLong} />
            </div>
        </Card>
    );
};

const ColorPickerInput: FC<{ label: string; value: string; onChange: (value: string) => void }> = ({ label, value, onChange }) => (
    <div>
        <Label className="mb-2 block">{label}</Label>
        <Popover>
            <PopoverTrigger asChild>
                <Button variant="outline" className="w-full justify-start text-left font-normal gap-2">
                    <div className="w-5 h-5 rounded-sm border" style={{ backgroundColor: value }} />
                    <span className="flex-1 truncate">{value}</span>
                </Button>
            </PopoverTrigger>
            <PopoverContent className="w-80 p-4 border-none bg-card/80 backdrop-blur-xl shadow-2xl">
                <ColorPicker value={value} onChange={onChange} className="w-full">
                    <ColorPickerSelection className="h-40" />
                    <ColorPickerHue className="h-4" />
                    <ColorPickerAlpha className="h-4" />
                    <div className="flex items-center justify-between pt-2">
                        <ColorPickerEyeDropper />
                        <ColorPickerOutput />
                    </div>
                    <ColorPickerFormat />
                </ColorPicker>
            </PopoverContent>
        </Popover>
    </div>
);

const AnimatedCard: FC<{ children: React.ReactNode; delay?: number; className?: string }> = ({ children, delay = 0, className }) => {
    const isVisible = useFadeIn(delay);

    return (
        <Card
            style={{ opacity: 0, backgroundColor: 'transparent' }}
            className={cn(
                "border-white/10 transition-all duration-1000 ease-out",
                isVisible
                    ? "!opacity-100 bg-card/60 backdrop-blur-xl translate-y-0"
                    : "!opacity-0 bg-transparent backdrop-blur-none translate-y-8",
                className
            )}
        >
            {children}
        </Card>
    );
};

const QrCodeControls: FC<QrCodeControlsProps> = ({
    text,
    onTextChange,
    level,
    onLevelChange,
    fgColor,
    onFgColorChange,
    bgColor,
    onBgColorChange,
    onImageUpload,
    logoUrl,
    onLogoUrlChange,
    onRemoveLogo,
    finalLogoSrc,
    className,
    delay = 0
}) => (
    <div className={cn("lg:col-span-1 space-y-6 flex flex-col h-full", className)}>
        <AnimatedCard delay={delay} className="flex flex-col flex-grow">
            <CardHeader>
                <CardTitle className="flex items-center gap-2"><Type size={18} /> Content</CardTitle>
            </CardHeader>
            <CardContent className='flex flex-col flex-grow'>
                <Textarea value={text} onChange={e => onTextChange(e.target.value)} placeholder="Enter text or URL" className="flex-grow min-h-28" />
                <Separator className="my-4" />
                <Label className="mb-2 block">Error Correction</Label>
                <Select value={level} onValueChange={onLevelChange}>
                    <SelectTrigger><SelectValue placeholder="Select level" /></SelectTrigger>
                    <SelectContent>
                        <SelectItem value="L">Low</SelectItem>
                        <SelectItem value="M">Medium</SelectItem>
                        <SelectItem value="Q">Quartile</SelectItem>
                        <SelectItem value="H">High</SelectItem>
                    </SelectContent>
                </Select>
            </CardContent>
        </AnimatedCard>

        <AnimatedCard delay={delay + 100}>
            <CardHeader>
                <CardTitle className="flex items-center gap-2"><Palette size={18} /> Style</CardTitle>
            </CardHeader>
            <CardContent className="grid grid-cols-2 gap-4">
                <ColorPickerInput label="Foreground" value={fgColor} onChange={onFgColorChange} />
                <ColorPickerInput label="Background" value={bgColor} onChange={onBgColorChange} />
            </CardContent>
        </AnimatedCard>

        <AnimatedCard delay={delay + 200}>
            <CardHeader>
                <CardTitle className="flex items-center gap-2"><ImageIcon size={18} /> Logo</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
                <Button asChild variant="outline" className="w-full">
                    <Label htmlFor="logoFile" className="cursor-pointer">
                        <UploadCloud className="mr-2 h-4 w-4" />
                        Upload an Image
                    </Label>
                </Button>
                <Input id="logoFile" type="file" accept="image/png, image/jpeg, image/svg+xml" onChange={onImageUpload} className="hidden" />

                <div className="relative flex justify-center">
                    <Separator className="absolute top-1/2 -translate-y-1/2 w-full" />
                    <span className="text-xs text-muted-foreground bg-card px-2 relative z-10">OR</span>
                </div>
                <div>
                    <Label htmlFor="logoUrl" className="mb-2 block text-sm">Paste Image URL</Label>
                    <div className="relative">
                        <Link className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                        <Input id="logoUrl" type="url" placeholder="https://example.com/logo.png" value={logoUrl} onChange={e => onLogoUrlChange(e.target.value)} className="pl-9" />
                    </div>
                </div>

                {finalLogoSrc && (
                    <div className="pt-2 space-y-3">
                        <Separator />
                        <div className="flex items-center justify-between gap-4">
                            <div className="flex items-center gap-3 min-w-0">
                                <img src={finalLogoSrc} alt="Logo Preview" className="h-12 w-12 rounded-md border object-contain p-1 flex-shrink-0" />
                                <p className="text-sm font-medium text-foreground truncate">Logo Preview</p>
                            </div>
                            <Button variant="ghost" size="icon" className="text-destructive hover:text-destructive flex-shrink-0" onClick={onRemoveLogo}>
                                <Trash2 className="h-4 w-4" />
                            </Button>
                        </div>
                    </div>
                )}
            </CardContent>
        </AnimatedCard>
    </div>
);

// --- Main Component ---
// Approximate character limits for alphanumeric data per error correction level.
const QR_CAPACITY_MAP: Record<Level, number> = {
    L: 2953, // Low
    M: 2331, // Medium
    Q: 1663, // Quartile
    H: 1273, // High
};

export const QRCodeGenerator = () => {
    const [text, setText] = useState('http://ave.dee.isep.ipp.pt/~1250182');
    const [size, setSize] = useState(512);
    const [fgColor, setFgColor] = useState('#000000');
    const [bgColor, setBgColor] = useState('#ffffff');
    const [level, setLevel] = useState<Level>('M');
    const [logoImage, setLogoImage] = useState<string | null>(null);
    const [logoUrl, setLogoUrl] = useState<string>('');
    const debouncedText = useDebounce(text, 500);
    const debouncedLogoUrl = useDebounce(logoUrl, 500);
    const qrRef = useRef<HTMLDivElement>(null);
    const [isDesktop, setIsDesktop] = useState(false);
    const [pageLoaded, setPageLoaded] = useState(false);
    const [showBackground, setShowBackground] = useState(false);

    useEffect(() => {
        // Trigger page load animation immediately
        setPageLoaded(true);

        // Delay background appearance by 300ms, then fade in slowly
        const bgTimer = setTimeout(() => {
            setShowBackground(true);
        }, 300);

        return () => clearTimeout(bgTimer);
    }, []);

    useEffect(() => {
        const mediaQuery = window.matchMedia('(min-width: 1024px)'); // lg breakpoint
        const handleMediaQueryChange = (e: MediaQueryListEvent) => {
            setIsDesktop(e.matches);
        };
        setIsDesktop(mediaQuery.matches);
        mediaQuery.addEventListener('change', handleMediaQueryChange);
        return () => {
            mediaQuery.removeEventListener('change', handleMediaQueryChange);
        };
    }, []);

    const isTooLong = debouncedText.length > QR_CAPACITY_MAP[level];

    const handleImageUpload = (e: ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            const reader = new FileReader();
            reader.onloadend = () => {
                setLogoImage(reader.result as string);
                setLogoUrl('');
            };
            reader.readAsDataURL(file);
        }
    };

    const handleLogoUrlChange = (value: string) => {
        setLogoUrl(value);
        if (value) {
            setLogoImage(null);
        }
    };

    const removeLogo = () => {
        setLogoImage(null);
        setLogoUrl('');
        const fileInput = document.getElementById('logoFile') as HTMLInputElement;
        if (fileInput) {
            fileInput.value = '';
        }
    };

    const handleDownloadRaster = (format: 'png' | 'jpeg') => {
        const svgElement = qrRef.current?.querySelector('svg');
        if (svgElement) {
            const svgString = new XMLSerializer().serializeToString(svgElement);
            const canvas = document.createElement('canvas');
            const userSize = options.size;
            canvas.width = userSize;
            canvas.height = userSize;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            const img = new window.Image();
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            img.onload = () => {
                ctx.save();
                if (format === 'jpeg' || (bgColor && bgColor !== '#ffffff00' && bgColor !== 'transparent')) {
                    ctx.fillStyle = bgColor || '#ffffff';
                    ctx.fillRect(0, 0, userSize, userSize);
                }
                ctx.drawImage(img, 0, 0, userSize, userSize);
                ctx.restore();
                URL.revokeObjectURL(url);

                const dataUrl = canvas.toDataURL(`image/${format}`, 1.0);
                const link = document.createElement('a');
                link.download = `qrcode.${format}`;
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };
            img.src = url;
        }
    };

    const handleDownloadSVG = () => {
        const svgElement = qrRef.current?.querySelector('svg');
        if (svgElement) {
            const svgString = new XMLSerializer().serializeToString(svgElement);
            const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'qrcode.svg';
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
    };

    const handleFormatSelect = (format: 'png' | 'jpeg' | 'svg') => {
        if (format === 'svg') {
            handleDownloadSVG();
        } else {
            handleDownloadRaster(format);
        }
    };

    const finalLogoSrc = logoImage || debouncedLogoUrl;

    const options: QrCodeOptions = {
        value: debouncedText,
        size: size,
        fgColor: fgColor,
        bgColor: bgColor,
        level: level,
        imageSettings: finalLogoSrc ? {
            src: finalLogoSrc,
            height: size * 0.2,
            width: size * 0.2,
            excavate: true,
        } : undefined,
    };

    return (
        <div className="relative h-full">
            {/* Page load fade-in overlay */}
            <div
                className="fixed inset-0 bg-black pointer-events-none transition-opacity duration-700 ease-out z-50"
                style={{ opacity: pageLoaded ? 0 : 1 }}
            />

            {isDesktop && (
                <div
                    className="fixed inset-0 -z-10 transition-opacity duration-[2000ms] ease-in-out"
                    style={{ opacity: showBackground ? 1 : 0 }}
                >
                    <PixelBlast
                        variant="circle"
                        pixelSize={6}
                        color="#B19EEF"
                        patternScale={3}
                        patternDensity={1.2}
                        pixelSizeJitter={0.5}
                        enableRipples
                        rippleSpeed={0.4}
                        rippleThickness={0.12}
                        rippleIntensityScale={1.5}
                        liquid
                        liquidStrength={0.12}
                        liquidRadius={1.2}
                        liquidWobbleSpeed={5}
                        speed={0.6}
                        edgeFade={0.25}
                        transparent
                    />
                </div>
            )}

            <div className="w-full flex flex-col lg:grid lg:grid-cols-3 gap-8 h-full">
                <QrCodeControls
                    className="order-2 lg:order-1"
                    text={text} onTextChange={setText}
                    level={level} onLevelChange={(value) => setLevel(value as Level)}
                    fgColor={fgColor} onFgColorChange={setFgColor}
                    bgColor={bgColor} onBgColorChange={setBgColor}
                    onImageUpload={handleImageUpload}
                    logoUrl={logoUrl} onLogoUrlChange={handleLogoUrlChange}
                    onRemoveLogo={removeLogo}
                    finalLogoSrc={finalLogoSrc}
                    delay={200}
                />
                <QrCodePreview
                    className="order-1 lg:order-2"
                    qrRef={qrRef}
                    options={options}
                    size={size}
                    onSizeChange={setSize}
                    onFormatSelect={handleFormatSelect}
                    isTooLong={isTooLong}
                    delay={0}
                />
            </div>
        </div>
    );
};
--- END OF FILE src/pages/tools/QRCodeGenerator.tsx ---
